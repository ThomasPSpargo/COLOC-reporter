#####
# Author: Thomas Spargo (thomas.spargo@kcl.ac.uk)
# Obtained from GitHub repository: https://github.com/ThomasPSpargo/COLOC-reporter
#
# This script performs colocalisation analysis between two traits at a specified genomic region. 
# Preprocessing and finemapping are handled per-trait and colocalisation analysis is performed with the COLOC software, either using coloc.abf or coloc.susie.
#####
suppressPackageStartupMessages(library(optparse))

option_list = list(
  
  #General options
  make_option("--LAVAfile", action="store", default=NA, type='character',
              help='Path to bivariate genetic correlation summary generated by LAVA. The script extract the locus with the smallest p-value by default. To analyse other genomic regions use the --set_locus option. If --set_locus specifies a comma separated genomic region directly list of the format "chromosome,start_position,end_position" (e.g. 17,43460501,44865832) then no --LAVAfile is required.'),
  make_option("--plink", action="store", default='plink', type='character',
              help="Path to PLINK executable (syntax written for PLINK 1.9). By default, has the value 'plink'"),
  make_option("--traits", action="store", default=NULL, type='character',
              help="Comma separated list of IDs for traits to analyse (e.g. 'P1,P2'), as relevant to the summary statistics provided in --sumstat1 and --sumstat2 options."),
  make_option("--traitLabel1", action="store", default=NULL, type='character',
              help="Character string giving a 'long' name for the first trait. To be used in plotting. If NULL, will default to the trait ID."),
  make_option("--traitLabel2", action="store", default=NULL, type='character',
              help="Character string giving a 'long' name for the second trait. To be used in plotting.If NULL, will default to the trait ID. This option is not affected by --match_sum1_opts."),
  make_option("--set_locus", action="store", default=NA, type='character',
              help='Specify target locus to test, either as a number referring to a locus from --LAVAfile, or as a comma separated list of the format "chromosome,start_position,end_position" (e.g. 17,43460501,44865832).'),
  make_option("--LDreference", action="store", default=NA, type='character',
              help="Path to, and prefix for, per-chromosome PLINK binary files used to compute LD matrix for SNPs in region. This input is used by SuSiE. Expected format of <prefix>i.bim, where i is the chromosome number"),
  make_option("--GWASconfig", action="store", default=NULL, type='character',
              help="Path to file specifying configuration of GWAS sumstats. Configuration will be determined by identifying rows whose IDs match the --traits option."),
  make_option("--match_sum1_opts", action="store", default=FALSE, type='logical',
              help="Specify whether duplicated options in summary stats 2 match those of sumstats 1. If TRUE they will be set automatically, unless option is specifically given [logical, defaults to FALSE]"),
  make_option("--runMode", action="store", default="trySusie", type='character',
              help="Character string, any of 'trySusie', 'skipSusie', 'doBoth'.\nIf 'doBoth', both coloc.abf and coloc.susie will attempt to run.\nIf 'trySusie' coloc.susie will be used if SuSiE finemapping identifies at least 1 credible set in each trait and coloc.abf is returned if the SuSiE finemapping step fails.\nIf 'skipSusie', only coloc.abf will be applied, and processes necessary for coloc.susie are skipped (e.g. no need to call to plink and generate LD matrix); the LD reference will however still still used for SNP alignment."),
  make_option("--force_matrix", action="store", default=FALSE, type='logical',
              help="If TRUE, the LD matrix will always be recomputed using PLINK. If FALSE, the default, the LD matrix will only be computed if the expected ld_matrix.snplist and ld_matrix.ld files are absent from the <output>/LDmatrix directory."),
  make_option("--out", action="store", default="./COLOC-reporter", type='character',
              help="Path and prefix for directory in which to return all outputs. Defaults to ./COLOC-reporter. When running multiple analyses, unique output directories are essential for tidy file organisation."),
  make_option("--GWASsumplots", action="store", default="p", type='character',
              help="Character string or vector with any combination of c('PIP','p','z','beta'); defaults to 'p'. Generate ggplots comparing summary statistic results on named statistic for both traits. See also the associated --GWASsumplots_onefile --GWASsumplots_incfinemapping options. PIP refers to posterior inclusion probabilities for snps as indicated from SuSiE"),
  make_option("--GWASsumplots_onefile", action="store", default=FALSE, type='logical',
              help="Logical, defaults to FALSE. When --GWASsumplots has more then one element, indicate TRUE to return all comparisons bound into a single figure; plots will be stacked vertically, in the order of the --GWASsumplots vector."),
  make_option("--GWASsumplots_incfinemapping", action="store", default=TRUE, type='logical',
              help="Logical, defaults to TRUE. If TRUE, and if any credible sets are identified across the two traits, plots returned by --GWASsumplots will include colouring indicating which snps belong to which credible sets."),
  make_option("--genomeAlignment", action="store", default=37, type='numeric',
              help="Indicate the reference genome to which summary statistics and LD reference are aligned. Defaults to 37,"),
  
  #Options For summary statistics 1 (will also be applied to summary statistics 2 if --match_sum1_cols TRUE and if options are not otherwise specified)
  make_option("--sumstat1", action="store", default=NA, type='character',
              help="Path to summary statistics for primary file"),
  make_option("--type1", action="store", default=NA, type='character',
              help="Indicate whether phenotype is 'quant' or 'cc' (case control)"),
  make_option("--prop1", action="store", default=0.5, type='numeric',
              help="For cc trait, Indicate proportion of data is from cases"),
  make_option("--pcolumn1", action="store", default=NA, type='character',
              help="Column name for p-values"),
  make_option("--statcol1", action="store", default=NA, type='character',
              help="Column name for test statistic, expects column referring to the beta coefficients, if odds ratios given, column must be called 'OR' "),
  make_option("--Ncol1", action="store", default=NA, type='character',
              help="Column name for each snp sample size"),
  make_option("--chromosome1", action="store", default=NA, type='character',
              help="Column name for chromosome"),
  make_option("--positions1", action="store", default=NA, type='character',
              help="Column name for genomic position"),
  make_option("--error1", action="store", default=NA, type='character',
              help="Column name for test statistic error"),
  make_option("--snpcol1", action="store", default=NA, type='character',
              help="Column name for SNP ids"),
  make_option("--MAF1", action="store", default="REF.FREQ", type='character',
              help="Column name MAF information"),
  
  #Duplicated options for summary statistics 2
  make_option("--sumstat2", action="store", default=NA, type='character',
              help="Path to summary statistics for primary file"),
  make_option("--type2", action="store", default=NA, type='character',
              help="Indicate whether phenotype is 'quant' or 'cc' (case control)"),
  make_option("--prop2", action="store", default=0.5, type='numeric',
              help="For cc trait, Indicate proportion of data is from cases"),
  make_option("--pcolumn2", action="store", default=NA, type='character',
              help="Column name for p-values"),
  make_option("--statcol2", action="store", default=NA, type='character',
              help="Column name for test statistic, expects column referring to the beta coefficients, if odds ratios given, column must be called 'OR' "),
  make_option("--Ncol2", action="store", default=NA, type='character',
              help="Column name for each snp sample size"),
  make_option("--chromosome2", action="store", default=NA, type='character',
              help="Column name for chromosome"),
  make_option("--positions2", action="store", default=NA, type='character',
              help="Column name for genomic position"),
  make_option("--error2", action="store", default=NA, type='character',
              help="Column name for test statistic error"),
  make_option("--snpcol2", action="store", default=NA, type='character',
              help="Column name for SNP ids"),
  make_option("--MAF2", action="store", default="REF.FREQ", type='character',
              help="Column name MAF information")
)

opt = parse_args(OptionParser(option_list=option_list))

#######
### Begin script
#######
options(echo=TRUE)

suppressPackageStartupMessages({
  library(data.table) #To read in the datasets
  library(R.utils)    #Required reading gz files directly with fread
  library(dplyr)
  library(coloc)
  library(susieR)
  library(biomaRt)    #For ensembl library
  library(ggrepel)
  library(ggplot2)
  library(egg)     #arranging summary plot
})


test <- FALSE # test <- TRUE
if(test==TRUE){
  #####
  setwd("/Users/tom/OneDrive - King's College London/PhD/PhD project/COLOC/git.local.COLOC-reporter/testing")
  opt <- list()
  
  #Not needed
  #opt$LAVAfile <- "/scratch/users/k1802739/LAVA/results/PD.SZ.bivar"
  
  # # #TESTING V1
  opt$set_locus <- "17,43460501,44865832"
  opt$sumstat1 <- "./PD.sumstats.txt"
  opt$sumstat2 <- "./SZ.sumstats.txt"
  opt$MAF2 <- "REF.FREQ"
  opt$out <- "./testing_PD.SZ.chr17"
  opt$traits <- c("PD,SZ")
  opt$traitLabel1 <- "Parkinson's Disease"
  opt$traitLabel2 <- "Schizophrenia"
  
  #TESTING V2
  # opt$set_locus <- "9,27366480,28067454"
  # opt$sumstat1 <- "./ALS.sumstats.txt"
  # opt$sumstat2 <- "./SZ.sumstats.txt"
  # opt$MAF2 <- "REF.FREQ"
  # opt$out <- "./testing_ALS.SZ.chr9"
  #opt$traits <- c("ALS,SZ")
  # opt$traitLabel1 <- "Amyotrophic lateral sclerosis"
  # opt$traitLabel2 <- "Schizophrenia"
  
  # # #TESTING V3
  # opt$set_locus <- "16,86058598,86748867"
  # opt$sumstat1 <- "./ALS.sumstats.txt"
  # opt$sumstat2 <- "./PD.sumstats.txt"
  # opt$MAF2 <- "FREQ"
  # opt$out <- "./testing_ALS.PD.chr16"
  #opt$traits <- c("ALS,PD")
  # opt$traitLabel1 <- "Amyotrophic lateral sclerosis"
  # opt$traitLabel2 <- "Parkinson's Disease"
  
  opt$LDreference <- './EUR_phase3_chr'
  opt$runMode <- 'doBoth'
  opt$force_matrix <- FALSE
  opt$type1 <- "cc"
  opt$prop1 <- 0.5
  opt$pcolumn1 <- "P"
  opt$statcol1 <- "BETA"
  opt$Ncol1 <- "N"
  opt$chromosome1 <- "CHR"
  opt$positions1 <- "BP"
  opt$error1 <- "SE"
  opt$snpcol1 <- "SNP"
  opt$MAF1 <- "FREQ"
  opt$match_sum1_opts <- TRUE
  
  opt$genomeAlignment <- 37
  opt$GWASsumplots <- c("PIP","p","beta")
  opt$GWASsumplots_onefile <- FALSE
  opt$GWASsumplots_incfinemapping <- TRUE
  
  
  #Assign default options for testing, except opt$MAF2, which has unique name across sumstats
  opt$type2 <- opt$pcolumn2 <- opt$statcol2 <- opt$Ncol2 <- opt$chromosome2 <- opt$positions2 <- opt$error2 <- opt$snpcol2 <- NA
  opt$prop2 <- 0.5
}

#Extract names of traits compared, first dropping file path, and then any prefixes indicated by a preceding underscore
traits <- strsplit(opt$traits,",")[[1]][1:2]

if(!is.null(opt$GWASconfig)){
  
  #Read in the configuration options
  GWASconfig<- fread(opt$GWASconfig)
  
  #Identify the rows which correspond to trait ID1 and ID2
  Config.index <- c(which(GWASconfig$ID %in% traits[1]),
                    which(GWASconfig$ID %in% traits[2])
                    )
  
  opt$type1 <- GWASconfig$type[Config.index[1]]
  opt$prop1 <- GWASconfig$prop[Config.index[1]]
  opt$pcolumn1 <- GWASconfig$pcolumn[Config.index[1]]
  opt$statcol1 <- GWASconfig$statcol[Config.index[1]]
  opt$Ncol1 <- GWASconfig$Ncol[Config.index[1]]
  opt$chromosome1 <- GWASconfig$chromosome[Config.index[1]]
  opt$positions1 <- GWASconfig$positions[Config.index[1]]
  opt$error1 <- GWASconfig$error[Config.index[1]]
  opt$snpcol1 <- GWASconfig$snpcol[Config.index[1]]
  opt$MAF1 <- GWASconfig$MAF[Config.index[1]]
  opt$traitLabel1 <- GWASconfig$traitLabel[Config.index[1]]
  opt$sumstat1 <- GWASconfig$FILEPATH[Config.index[1]]
  
  opt$type2 <- GWASconfig$type[Config.index[2]]
  opt$prop2 <- GWASconfig$prop[Config.index[2]]
  opt$pcolumn2 <- GWASconfig$pcolumn[Config.index[2]]
  opt$statcol2 <- GWASconfig$statcol[Config.index[2]]
  opt$Ncol2 <- GWASconfig$Ncol[Config.index[2]]
  opt$chromosome2 <- GWASconfig$chromosome[Config.index[2]]
  opt$positions2 <- GWASconfig$positions[Config.index[2]]
  opt$error2 <- GWASconfig$error[Config.index[2]]
  opt$snpcol2 <- GWASconfig$snpcol[Config.index[2]]
  opt$MAF2 <- GWASconfig$MAF[Config.index[2]]
  opt$traitLabel2 <- GWASconfig$traitLabel[Config.index[2]]
  opt$sumstat2 <- GWASconfig$FILEPATH[Config.index[2]]
  
  Config_msg <- paste0("Summary statistic configuration options set according to the specification of --GWASconfig for trait IDs 1: ", traits[1], " and 2: ",traits[2],".\n")
} else {
  Config_msg <- ""
}

#If sumstat 2 options should match sumstat 1 options (indicated by --match_sum1_cols TRUE) match options which are not otherwise explicitly named
if(isTRUE(opt$match_sum1_opts) && is.null(opt$GWASconfig)){
  if(is.na(opt$pcolumn2)){opt$pcolumn2 <- opt$pcolumn1}
  if(is.na(opt$statcol2)){opt$statcol2 <- opt$statcol1}
  if(is.na(opt$Ncol2)){opt$Ncol2 <- opt$Ncol1}
  if(is.na(opt$chromosome2)){opt$chromosome2 <- opt$chromosome1}
  if(is.na(opt$positions2)){opt$positions2 <- opt$positions1}
  if(is.na(opt$error2)){opt$error2 <- opt$error1}
  if(is.na(opt$snpcol2)){opt$snpcol2 <- opt$snpcol1}
  if(is.na(opt$MAF2)){opt$MAF2 <- opt$MAF1}
  
  if(is.na(opt$type2)){opt$type2 <- opt$type1}
  if(opt$prop2==0.5){opt$prop2 <- opt$prop1}
}

#Assign names for use as labelling with the traits
names(traits) <- c(opt$traitLabel1, opt$traitLabel2) 


opt$out <- paste0(opt$out,"_coloc/")
if(!dir.exists(opt$out)){dir.create(opt$out,recursive = TRUE)}

#Set up directories in which to return tables and figures
figdir <- paste0(opt$out,"plots/")
if(!dir.exists(figdir)){dir.create(figdir)}
tabdir <- paste0(opt$out,"tables/")
if(!dir.exists(tabdir)){dir.create(tabdir)}

#Setup a colour palette to be used across ggplots (colours taken from plot SuSiE)
ggpalette = c("dodgerblue2", "green4", "#6A3D9A", "#FF7F00", 
              "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", 
              "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", 
              "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", 
              "yellow3", "darkorange4", "brown")

#Define a custom plotting function to be recycled for (optional) summary plots and later for plotting snp pp's
ggSummaryplot <- function(yaxis,xstring="pos",xlim,dset=minimal_P1P2_df,colourMapping=NULL,shapeMapping=NULL,figdir,traits,returnplot=TRUE,
                          facetTraits=FALSE,nameColourLegend="Trait: Credible set",nameShapeLegend=NULL,alignment){
  
  #Setup y-axis parameters
  if(tolower(yaxis)=="p"){
    ylab <- bquote(-log[10]~p)
    ystring <- "-log10(pvalues)"
  } else if (tolower(yaxis)=="z"){
    dset$z <- abs(dset$beta/dset$SE)
    ylab <- "Absolute Z-score"
    ystring <- "z"
  } else if(tolower(yaxis)=="pip"){
    ylab <-  "PIP"
    ystring <- "variable_prob"
  } else if(tolower(yaxis)=="snp.pp"){
    ylab <- "Posterior probability of being a shared variant\n"
    ystring <- "SNP.PP"
  } else {
    ylab <- yaxis
    ystring <- tolower(yaxis)
  }
  
  if(facetTraits==TRUE){
    dset$trait<- factor(dset$trait,levels=traits,labels = names(traits))
  }
  
  
  #Generate plot
  plot_root <- ggplot(dset,aes_string(x=xstring,y=ystring,color=colourMapping,shape=shapeMapping))+
    geom_point()+
    theme_bw()+
    xlim(xlim)+
    labs(y=ylab,x=paste0("GRCh",alignment," genomic position (",target_region,")"))
  
  if(facetTraits==TRUE){
    plot_root <- plot_root +
      facet_wrap(~trait, nrow = 1)
  }
  
  #Add Colouring if specified
  if(!is.null(colourMapping)){
    plot_root <- plot_root +
      scale_colour_manual(na.value = "black", values=ggpalette,
                          breaks=levels(dset[[which(colnames(dset)==colourMapping)]])
      )+
      guides(color=guide_legend(title=nameColourLegend,order=1))
  }
  
  #Add shapes if specified
  if(!is.null(shapeMapping)){
    plot_root <- plot_root +
      #scale_shape_manual(na.value = 19, values=17,breaks=levels(dset[[which(colnames(dset)==shapeMapping)]])
    scale_shape_manual(values=c(17,19),breaks=levels(dset[[which(colnames(dset)==shapeMapping)]])
                                            
      )+
      guides(shape=guide_legend(title=nameShapeLegend,order=2))
  }
  
  #Return either the plot itself or ggsave directly, according to return plot option
  if(returnplot){
    return(plot_root)
  } else {
    #GGsave returns character string indicating where file was written
    ggsave(paste0(figdir,paste0(traits,collapse="_"),"_",tolower(yaxis),"_summaryplot.pdf"),
           plot_root,device="pdf",units="mm",width=175,height=75)
  }
}


#Generate plots in a column with a shared legend, using custom function which wraps around egg::ggarrange and draws upon grid functionality to produce shared legend

#x is a list of ggplots to be stacked vertically and assigned a shared figure legend
#position of legend is either "right" or "bottom"
# ... arguments passed to egg::ggarrange

egg_ggarr_wlegend <- function(p,position="right",...){
  #Syntax developed based on
  #https://github.com/tidyverse/ggplot2/wiki/Share-a-legend-between-two-ggplot2-graphs
  
  # #Extract legend from first figure as a grob, then determine parameters
  g <- ggplotGrob(p[[1]] + theme(legend.position = position))$grobs
  is.legend <- which(sapply(g, function(x) x$name) == "guide-box")
  if(length(is.legend)>0){
    legend <- g[[is.legend]]
    lheight <- sum(legend$height)
    lwidth <- sum(legend$width)
    #Drop legend from individual plots
    p <-  lapply(p, function(x) x + theme(legend.position="none"))
  }
  
  
  #Always drop duplicated x-axis labeling elements, since columns are always stacked vertically
  p[1:(length(p)-1)] <-  lapply(p[1:(length(p)-1)], function(x) x + theme(axis.title.x = element_blank(),
                                                                          axis.line.x = element_blank(),
                                                                          axis.text.x = element_blank())
  )
  
  #Using egg_ggarrange, combine the plots with legend removed; egg::ggarrange ensures combined plots are well formatted
  eggP <- egg::ggarrange(plots=p,...)
  
  if(length(is.legend)>0){
    #Then, using grid functionality (which should be installed already, as a dependency of egg)
    eggP <- switch(position,
                   "bottom" = arrangeGrob(eggP,
                                          legend,
                                          ncol = 1,
                                          heights = grid::unit.c(grid::unit(1, "npc") - lheight, lheight)
                   ),
                   "right" = arrangeGrob(eggP,
                                         legend,
                                         ncol = 2,
                                         widths = grid::unit.c(grid::unit(1, "npc") - lwidth, lwidth)
                   ))
    
    grid::grid.newpage()
    grid::grid.draw(eggP)
 
    # return gtable invisibly
    invisible(eggP)
  }
  return(eggP)
}
sink(file = paste0(opt$out,'colocalisation.log'), append = F)
cat(
  '#################################################################
# colocaliseRegion.R
# Perform colocalisation analysis between GWAS summary statistics in a predetermined genomic region.
# Colocalisation leverages the COLOC and SuSiE software packages.
# Genetic regions must either identified manually or can be selected based on output from LAVA software.
# Documentation for options for running the script can be called with: Rscript ./colocaliseRegion.R --help
# 
# This script was written by Thomas Spargo (thomas.spargo@kcl.ac.uk), please get in touch with any queries.
#
#################################################################
Analysis started at',as.character(Sys.time()),'\n',Config_msg,'Options are:\n')
print(opt)

cat("\n######\n### Setup \n######\n\n")

cat("All outputs will be returned in the directory: ", opt$out,"\n")
cat("All figures are returned in the subdirectory: plots/\n")
cat("and tabular summaries in the subdirectory: tables/\n\n")

sink()

if(length(opt$GWASsumplots)>0){
  #Parse the comma delimited list
  opt$GWASsumplots <- strsplit(opt$GWASsumplots,",")[[1]]
  
  #Return warning if any of the gwas summary plot options are not recognised, then drop the unrecognised elements
  checksumplots<- tolower(opt$GWASsumplots) %in% c('pip','p','z','beta')
  if(any(!checksumplots)){
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("WARNING: The --GWASsumplots option contained unrecognised strings which have been dropped. Please indicate any combination of 'pip', 'p', 'z', 'beta', case-insensitive)")
    sink()
    
    opt$GWASsumplots <- opt$GWASsumplots[-which(checksumplots)] #Drop the unrecognised strings
  }
}
       
       
  

########
##### Import first dataset
########
#Import first dataset
sums1 <- tibble(fread(opt$sumstat1))

#Check for column name options match the dataset, warn if not
colcheck <-  which(!(
  c(opt$pcolumn1,opt$statcol1,opt$Ncol1,opt$chromosome1,opt$positions1,opt$error1,opt$snpcol1,opt$MAF1)
  %in% colnames(sums1)
))
if(length(colcheck)>0){
  warning("The column names expected for the 1st set of summary statistics based on options set were not all detected when reading in the file. Please check the option(s) specified.")
}

#Unless specified to be an odds ratio, rename as beta
if(opt$statcol1=="OR"){
  sums1$beta <- log(sums1$OR)
  sums1$OR <- NULL
} else {
  colnames(sums1)[colnames(sums1)==opt$statcol1] <- "beta"
}

#Standardise other column names
names(sums1)[names(sums1)==opt$pcolumn1] <- "pvalues"
names(sums1)[names(sums1)==opt$chromosome1] <- "chr"
names(sums1)[names(sums1)==opt$positions1] <- "pos"
names(sums1)[names(sums1)==opt$error1] <- "SE"
names(sums1)[names(sums1)==opt$snpcol1] <- "snp"
names(sums1)[names(sums1)==opt$MAF1] <- "MAF"


########
##### Import second dataset
########
#Parameters for the second dataset Copy from 1

#...
#Import data
sums2 <- tibble(fread(opt$sumstat2))

#Check for column name options match the dataset
colcheck <-  which(!(
  c(opt$pcolumn2,opt$statcol2,opt$Ncol2,opt$chromosome2,opt$positions2,opt$error2,opt$snpcol2,opt$MAF2)
  %in% colnames(sums2)
))
if(length(colcheck)>0){
  warning("The column names expected for the 1st set of summary statistics based on options set were not all detected when reading in the file. Please check the option(s) specified.\n
          Note that these names may have been automatically assigned based on values for summary statistics 1 if --match_sum1_opts is set as TRUE")
}

if(opt$statcol2=="OR"){
  sums2$beta <- log(sums2$OR)
  sums2$OR <- NULL
} else {
  colnames(sums2)[colnames(sums2)==opt$statcol2] <- "beta"
}


#Standardise the names based on input options
names(sums2)[names(sums2)==opt$pcolumn2] <- "pvalues"
names(sums2)[names(sums2)==opt$chromosome2] <- "chr"
names(sums2)[names(sums2)==opt$positions2] <- "pos"
names(sums2)[names(sums2)==opt$error2] <- "SE"
names(sums2)[names(sums2)==opt$snpcol2] <- "snp"
names(sums2)[names(sums2)==opt$MAF2] <- "MAF"



########
#### Filter dataset into interest region
########
if(!is.na(opt$set_locus)){
  
  opt$set_locus <- as.numeric(strsplit(opt$set_locus,",")[[1]])
  
  if(length(opt$set_locus)==3){
    #Set genomic positions manually
    reg_range <-c(chr=opt$set_locus[1],
                   start=opt$set_locus[2],
                   stop=opt$set_locus[3])
    
  } else if(length(opt$set_locus)!=1) {
    stop('The option --set_locus is defined but cannot be identified as specifying a genomic region manually (in the comma separated format "chromosome,start_position,end_position") or as single numeric referring to local genetic correlation locus from LAVA')
  } else {
    
    if(is.na(opt$LAVAfile)){
      stop('please set the option --LAVAfile when passing a single numeric in the --set_locus option; this numeric refers to the genomic region flagged by the locus number from LAVA.\n\nNote that --set_locus also accepts a manually defined genomic region (in the comma separated format "chromosome,start_position,end_position"), and the --LAVAfile option is ignored in this circumstance')
    }
    
    #Read the lava input, and extract the locus named
    LAVAfile <- tibble(fread(opt$LAVAfile))
    LAVAregion <- which(LAVAfile$locus==opt$set_locus)
    
    reg_range <-c( chr=LAVAfile$chr[LAVAregion],
                   start=LAVAfile$start[LAVAregion],
                   stop=LAVAfile$stop[LAVAregion])
  }
} else {
  #Read the lava input, and extract the locus with the smallest p-value
  LAVAfile <- tibble(fread(opt$LAVAfile))
  LAVAregion <- which(LAVAfile$p==min(LAVAfile$p))
  
  reg_range <-c( chr=LAVAfile$chr[LAVAregion],
                 start=LAVAfile$start[LAVAregion],
                 stop=LAVAfile$stop[LAVAregion])
}

target_region <- paste0("chr",reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"])

sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
cat(paste0("Colocalisation analysis will be performed for the region: ", target_region," \n"))
sink()


######
# Harmonise summary statistics
######

# Read in reference SNP data to match alleles 
bim<-fread(paste0(opt$LDreference,reg_range["chr"],'.bim'))

#Drop sumstats 1 to snps in the chromosome:position range and present in the LD reference data
#Mutate to calculate the variance of the beta from standard error and N
sums1.region <- sums1 %>%
  filter(chr==reg_range["chr"],
         pos>=reg_range["start"],
         pos<=reg_range["stop"],
         snp %in% bim[["V2"]]
  ) %>%
  arrange(match(snp, bim[["V2"]]))

sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
cat("Number of SNPs from sumstat 1 in tested region and LD reference:", nrow(sums1.region),"\n")
sink()

# #Repeat filtering for sumstats 2
sums2.region <- sums2 %>%
  filter(chr==reg_range["chr"],
         pos>=reg_range["start"],
         pos<=reg_range["stop"],
         snp %in% bim[["V2"]]
  ) %>%
  arrange(match(snp, bim[["V2"]]))
  

sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
cat("Number of SNPs from sumstat 2 in tested region and LD reference:", nrow(sums2.region),"\n")
sink()

#Intersect the two snp lists
snplist <- intersect(sums1.region$snp, sums2.region$snp)

sink(file = paste0(opt$out,'colocalisation.log'), append = T)
#Print some information to console
cat(paste0("N SNPs overlapping for both traits: ", length(snplist),"\n"))
sink()

#Intersect the overlapping SNPSs, and compute varbeta and position evidence
sums1.region <- sums1.region %>%
  filter(snp %in% snplist) %>%
  mutate(varbeta = SE^2,
         position = row_number())

sums2.region <- sums2.region %>%
  filter(snp %in% snplist) %>%
  mutate(varbeta = SE^2,
         position = row_number())






# Flip sumstat direction to match alleles across gwas and reference,
# also reverse allele frequency to refer to new effect allele
alignSS <- function(ss,bim){
  ss_bim_match<-merge(ss, bim, by.x=c('snp','A1','A2'), by.y=c('V2','V5','V6'))
  ss_bim_swap<-merge(ss, bim, by.x=c('snp','A1','A2'), by.y=c('V2','V6','V5'))
  
  ss<-ss[ss$snp %in% ss_bim_match$snp | ss$snp %in% ss_bim_swap$snp,] 
  ss$beta[ss$snp %in% ss_bim_swap$snp] <- -ss$beta[ss$snp %in% ss_bim_swap$snp]
  
  ss$MAF[ss$snp %in% ss_bim_swap$snp] <- 1-ss$MAF[ss$snp %in% ss_bim_swap$snp]
  
  return(ss)
}
sums1.region <- alignSS(sums1.region,bim)
sums2.region <- alignSS(sums2.region,bim)

#Return warning if the SNP position alignment seems incorrect
if(!identical(paste0(sums1.region$snp,"_",sums1.region$pos),
             paste0(sums2.region$snp,"_",sums2.region$pos))){
  sink(file = paste0(opt$out,'colocalisation.log'), append = T)
  cat("WARNING: SNP names and genomic positions do not match between datasets. Please check that these have been aligned correctly.")
  sink()
}


######
# Generate LD matrix (for SuSiE)
######


if(opt$runMode %in% c("trySusie", "doBoth")){
  #Extract snps and write list to file in subdirectory of results directory
  
  #Check for the expected LD matrix output; if files are absent or if --force_matrix is set, generate using PLINK
  expect <- c(".snplist",".ld")
  expect <- paste0(opt$out,'LDmatrix/ld_matrix',expect)
  
  if(any(!file.exists(expect)) | opt$force_matrix){
    
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("Computing LD matrix...")
    sink()
    
    ld_dir<- dirname(expect[1])
    
    if(!dir.exists(ld_dir)){dir.create(ld_dir,recursive = TRUE)}
    write(snplist, file=paste0(ld_dir,"/snplist.txt"))
    
    #Identify LD matrixsnps from snplist present in reference
    #Syntax based on plink v 1.9
    system(paste0(opt$plink,' --bfile ', opt$LDreference,reg_range["chr"],
                  ' --extract ',ld_dir,'/snplist.txt',
                  ' --r square',
                  ' --write-snplist',
                  ' --keep-allele-order',
                  ' --out ',ld_dir,'/ld_matrix'))
    
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("Done\n")
    sink()
    
  } else {
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("Existing LD matrix found, skipping call to PLINK\n")
    sink()
  }
  
  #Read in the ld matrix and snp names as returned by plink 
  ld <- as.matrix(fread(expect[2]))
  ld_names<- scan(expect[1],what=character())
  dimnames(ld)<-list(ld_names, ld_names) #assign dimnames to LD object
  
  #As a sanity check, redo alignment based on plink output order to ensure snps are correctly arranged in base pair order, and assign 'positions' for coloc
  sums1.region <- sums1.region %>%
    filter(snp %in% all_of(ld_names)) %>%
    arrange(match(snp, ld_names)) %>%
    mutate(position = row_number())
  
  sums2.region <- sums2.region %>%
    filter(snp %in% all_of(ld_names)) %>%
    arrange(match(snp, ld_names)) %>%
    mutate(position = row_number())
} 


######
# If doing summary plotting, extract a minimal combination of statistics from the harmonised datasets
# this will be used in plotting after attempting finemapping step
######
if(length(opt$GWASsumplots)>0){
  p_z_plotcols <-  c("snp","pos","beta","SE","pvalues")
  minimal_P1P2_df<- cbind(sums1.region[,p_z_plotcols],trait=unname(traits)[1]) %>%
    full_join(cbind(sums2.region[,p_z_plotcols],trait=unname(traits)[2]),by=c(p_z_plotcols,"trait"))
}


######
### Prepare for colocalisation analysis; convert data.frame to list and add expected list elements
######

##Expected elements:
#LD matrix (if passing via SuSiE)
#type = "cc" or "quant" depending on trait type
#s = case control proportion if "cc"
sums1.region <- as.list(sums1.region)
sums1.region$type <- opt$type1
if(opt$type1=="cc"){sums1.region$s <- opt$prop1}
if(opt$runMode %in% c("trySusie", "doBoth")){sums1.region$LD <- ld}

sums2.region <- as.list(sums2.region)
sums2.region$type <- opt$type2
if(opt$type2=="cc"){sums2.region$s <- opt$prop2}
if(opt$runMode %in% c("trySusie", "doBoth")){sums2.region$LD <- ld}



#Import gene information for region
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=opt$genomeAlignment)
Genes<-getBM(attributes=c('external_gene_name','chromosome_name','start_position','end_position','external_gene_source'), mart = ensembl)

# Use 10kb window to define gene window
gene_window<-10000
Genes$start_window<-Genes$start_position-gene_window
Genes$end_window<-Genes$end_position+gene_window


# Do main Susie steps
if(opt$runMode %in% c("trySusie", "doBoth")){
  
  ######
  ### Define function to summarise susie results for both datasets
  ######
  susie_report <- function(susie.fit,basedata,trait){
    #Drop the list elements of basedata which cannot be converted to a dataframe, and then convert
    basedata$s <- basedata$type <- basedata$LD <- NULL
    basedata <- as.data.frame(basedata)
    
    sum_susie <- summary(susie.fit)
    csFound<- !is.null(sum_susie$cs) #Logical statement to pass through indicating TRUE if a CS has been identified
    
    ##### Generate summary table for PIP of SNPs
    sets<- sum_susie$vars #[sum_susie$vars$cs!=-1,] #Extract all snps
    sets<- cbind(sets,basedata[sets$variable,c("snp","chr","pos","pvalues","beta","SE")]) #Add relevant columns from GWAS sumstats
    
    #Save PIP summaries to file
    sets_outpath<- paste0(tabdir,"susie_snp_summary_",trait,".csv")
    write.table(sets,file=sets_outpath,sep = ",",row.names=FALSE)
    tab_out<- paste0("PIP summaries for SNPs for ",trait," are tabulated in:\n", basename(sets_outpath),"\n") #Info string
    
    ### Plot the pip summaries alongside snp p-values
    
    #Mutate data for plotting
    sets <- sets %>%
      mutate(cs = if_else(cs==-1,NA_real_,cs),
             cs = as.factor(cs),
             thresh = if_else(!is.na(cs),as.character(snp),""))
    
    if(csFound){ #if CS are found
      colourMapping <- "cs" #Dynamically set colour attribute 
      
      #Replicate Susie plot legend labelling
      CSlen<- sapply(susie.fit$sets$cs,length)
      CSmin<- susie.fit$sets$purity$min.abs.corr
      levels(sets$cs) <- paste0(names(susie.fit$sets$cs),": C=",CSlen,"/R=",round(CSmin,3))
      
    } else {
      colourMapping <- NULL
    }
    
    #Use trait name as plot title if possible
    if(!is.null(names(trait))){
      title <- names(trait)
    } else {
      title <- trait
    }
    
    pips<- ggplot(sets,aes_string(x="pos",y="variable_prob",color=colourMapping))+
      geom_point() +
      theme_bw()+
      theme(plot.title = element_text(hjust=0.5))+
      labs(y="PIP",x=paste0("GRCh",opt$genomeAlignment," genomic position (",target_region,")"),title=title)
    
    #Add colours to plots if a credible set has been identified
    if(!is.null(colourMapping)){
      pips <- pips +
        scale_colour_manual(na.value = "black", values=ggpalette,breaks=levels(sets$cs))+
        guides(color=guide_legend(title="Credible set"))
    }
    
    ggsave(paste0(figdir,"susie_PIP_",trait,".pdf"),pips,device="pdf",units="mm",width=150,height=150)
    
    if(csFound){
      ##### Create summary file    
      finemap_summary <- data.frame(CS_span = NA,
                                    beta_maxSNP = basedata$snp[which(basedata$beta==max(basedata$beta))],
                                    p_minSNP = basedata$snp[which(basedata$pvalues==min(basedata$pvalues))],
                                    TopPIPsnp = NA,
                                    sum_susie$cs,
                                    NSNP=NA,
                                    TopPIP=NA,
                                    Genes_near_span=NA)
      
      for(j in 1:nrow(sum_susie$cs)){
        snp_index<-as.numeric(unlist(strsplit(finemap_summary$variable[j], ',')))
        
        finemap_summary$NSNP[j] <- length(snp_index)
        finemap_summary$TopPIP[j]<-max(susie.fit$pip[snp_index])
        finemap_summary$TopPIPsnp[j]<- paste(names(susie.fit$pip)[susie.fit$pip==finemap_summary$TopPIP[j]], collapse=', ')
        
        ss_subset<-basedata[(basedata$snp %in% names(susie.fit$pip)[snp_index]),]
        min_bp<-min(ss_subset$pos)
        max_bp<-max(ss_subset$pos)
        chr<-ss_subset$chr[1]
        
        finemap_summary$CS_span[j]<- paste0("chr",chr,":",min_bp,"-",max_bp) #span of credible set
        
        Genes_subset<- Genes[Genes$chromosome_name == chr & (
          (Genes$start_window >= min_bp & Genes$start_window <= max_bp) | #Test if start position is within range
            (Genes$end_window >= min_bp & Genes$end_window <= max_bp) |   #or if end position is within range
            (Genes$start_window <= min_bp & Genes$end_window >= max_bp)   #or if start and end positions are both outside range [gene straddles window]
        ),]
        
        if(nrow(Genes_subset) > 0){
          #Write the gene names
          finemap_summary$Genes_near_span[j]<-paste(Genes_subset$external_gene_name, collapse=', ')
          
          #Save details for genes near to credible set #NO MENTION OF THIS OUTPUT IN THE REPORT
          sets_outpath<- paste0(tabdir,"nearby_genes_",trait,"_cs",j,".csv")
          Genes_subset %>%
            dplyr::select(-c(start_window,end_window)) %>%
            write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
          
        }
      }
      finemap_summary$variable <- NULL
      
      #Return output if there has been a credible set
      
    } else {
      finemap_summary <- "No 95% confidence credible sets could be identified"
    }
    
    #Sink directly to file
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("------------------------------\n")
    cat("SuSiE finemap result for", trait,":\n")
    print(finemap_summary)
    cat("\n",tab_out)
    cat("------------------------------\n")
    sink()
    
    #Return results just in case
    return(list(finemap_summary=finemap_summary,tab_out=tab_out,csFound=csFound, sets=sets))
  }
  
  #Catch failures in susie
  susiefail <- function(x=NULL,ntrait,isError=FALSE){warning(x)
    if(isError==TRUE){
      #Flag the fail in the global environment, only if there is a full error; warnings will not stop downward work
      assign(paste0("msg",ntrait),TRUE,envir=.GlobalEnv)
      
      type<- "error"
    } else {
      type<- "warning"
    }
    
    #If triggered, Return the error/warning in summary file
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("------------------------------\n")
    cat("SuSiE fine-mapping ", type," produced for", traits[ntrait],". Please see the following:\n")
    cat(type," in", toString(last.warning),":\n",names(last.warning),"\n")
    cat("------------------------------\n")
    sink()
  }
  
  sink(file = paste0(opt$out,'colocalisation.log'), append = T)
  cat("\n######\n### SuSiE fine-mapping results\n######\n\n")
  sink()
  #Run SuSiE for both datasets and generate report summaries
  #A guideline for N is specified since this is highly recommended
  msg1 <- FALSE
  tryCatch(susie1 <- runsusie(sums1.region,n=max(sums1.region$N)),
           #warning = function(x){susiefail(x,1)},
           error   = function(x){susiefail(x,1,isError=TRUE)})
  msg2 <- FALSE
  tryCatch(susie2 <- runsusie(sums2.region,n=max(sums2.region$N)),
           #warning = function(x){susiefail(x,2)},
           error   = function(x){susiefail(x,2,isError=TRUE)})
  
  
  if(msg1==FALSE){
    susie1_rep <- susie_report(susie.fit=susie1,basedata=sums1.region,trait=traits[1])
  } else {
    #Empty list for downstream logic-checks
    susie1_rep <- list(csFound=FALSE,sets=data.frame(snp=snplist,
                                                     cs=factor(NA_character_),
                                                     variable_prob=NA_real_))
  }
  
  if(msg2==FALSE){
    susie2_rep <- susie_report(susie2,sums2.region,trait=traits[2])
  } else {
    #Empty list for downstream logic-checks
    susie2_rep <- list(csFound=FALSE,sets=data.frame(snp=snplist,
                                                     cs=factor(NA_character_),
                                                     variable_prob=NA_real_))
  }
  
  #Flag either of the SuSiE calls failed
  if(any(msg1,msg2)){
    
    ######
    ### Check alignment of Beta and LD, may lead to issues with LD matrix convergence if not aligned in the same direction
    ######
    pdf(file=paste0(figdir,"Beta_LD_alignment.pdf"),width=14,height=7)
    par(mfrow=c(1,2))
    check_alignment(sums1.region)
    check_alignment(sums2.region)
    dev.off()
    
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("The SuSiE fine-mapping step failed for at least one of the two traits (see above).\n")
    cat("The figure 'Beta_LD_alignment.pdf' has also been generated, which allows checking of alignment between summary statistic beta's and the LD matrix.\nSee https://chr1swallace.github.io/coloc/articles/a02_data.html for details.\n")
    sink()
    
  } else if(!all(susie1_rep$csFound,susie2_rep$csFound)){
    sink(file = paste0(opt$out,'colocalisation.log'), append = T)
    cat("Credible sets were not identified for at least one trait, thus coloc.susie cannot be utilised.\n")
    sink()
  }
} else {
  #If susie is skipped entirely, produce some dummy values that are required for subsequent logic checks
  susie1_rep <- susie2_rep <- list(csFound=FALSE, sets=data.frame(snp=snplist,
                                                                  cs=factor(NA_character_),
                                                                  variable_prob=NA_real_))
  msg1 <- msg2 <- FALSE
}

######
### Prepare for, and then generate Summary plots comparing the region-results for the two GWAS
######
if(length(opt$GWASsumplots)>0){
  
  #Extract PIPs for each trait 
  snp_PIP <- rbind(
    cbind(susie1_rep$sets[,c("snp","variable_prob")],trait=traits[1]),
    cbind(susie2_rep$sets[,c("snp","variable_prob")],trait=traits[2])
  )
  
  #Combine SuSiE PIP results with the minimal dataset
  minimal_P1P2_df <- minimal_P1P2_df %>%
    full_join(snp_PIP,by=c("snp","trait"))  #add each PIP
  
  #According to whether any CS have been found, add a CS column to the dataframe
  if(susie1_rep$csFound || susie2_rep$csFound){
    
    ###Function to create a character vector based on how variants are distributed across credible sets for each trait
    
    # x and y are dataframes with snp column used as an ID and cs column indicating credible set assignments as a factor. nrow(x) should equal nrow(y)
    # x/ytrait denote an identtifier for each trait
    joinLabels <- function(x, y,traits){
      
      # z is a factor class vector, trait is the associated trait
      refactor <- function(z,trait){
        #Reformat factor levels if not all NA
        len<- length(levels(z))
        if(len>0){levels(z) <- c(paste0(trait,":",1:len))}
        z <- addNA(z)                      #Add a NA factor level
        levels(z)[length(levels(z))] <- "" #Set NA level as empty string
        z
      }
      
      #Refactor both x and y traits
      x$cs<- refactor(x$cs,traits[1])
      y$cs<- refactor(y$cs,traits[2])
      
      #Combine into a snp and credible set data frame
      xy <- full_join(x,y,by="snp") %>%
        mutate(cs=case_when(cs.x == "" & cs.y == "" ~ NA_character_,
                            cs.x != "" & cs.y == "" ~ paste0(cs.x),
                            cs.x == "" & cs.y != "" ~ paste0(cs.y),
                            cs.x != "" & cs.y != "" ~ paste0(cs.x," & ",cs.y)),
               cs=as.factor(cs)
               ) %>%
        dplyr::select(snp,cs)
      
      xy
    }
    
    #Extract minimal credible set labels
    snp_CS<- joinLabels(x=susie1_rep$sets[,c("snp","cs")],y=susie2_rep$sets[,c("snp","cs")],traits=traits)
  
      
    #Combine SuSiE results with the minimal dataset
    minimal_P1P2_df <- minimal_P1P2_df %>%
      full_join(snp_CS,by="snp")          #add CS assignments
      
    
    colourMapping <- "cs" #Set colour attribute 
  } else {
    # #If no SuSiE, assign an empty column
    minimal_P1P2_df$cs <- NA_character_
    
    colourMapping <- NULL #Set colour attribute 
  }
  
  #If not including finemapping, override colourmapping and set to null
  if(opt$GWASsumplots_incfinemapping==FALSE){
    colourMapping <- NULL
  }

  
  #Dynamically plot gwas stat summary figures, varying the y-axis accordingly. This is subsequently called within lapply
  #Save files internally, or return plots, depending on the returnplot argument
  #Internally, recode plotting according to the element specified to 'yaxis'.
  ggsummaryplot <- lapply(opt$GWASsumplots,ggSummaryplot,xlim=c(reg_range["start"],reg_range["stop"]),colourMapping=colourMapping,figdir=figdir,traits=traits,
                          returnplot=opt$GWASsumplots_onefile,facetTraits=TRUE,alignment=opt$genomeAlignment)
  
  #Optionally combine all summary plots into a single file; this will be in the order specified 
  if(opt$GWASsumplots_onefile){
  
    if(length(ggsummaryplot)>1){
      #Save the arranged plot using custom function wrapped around egg::ggarrange
      jointPlots <- egg_ggarr_wlegend(ggsummaryplot,ncol=1)
      
    } else {
      #If only one plot, use it 'as is'
      jointPlots <- ggsummaryplot
      
    }
    
    height=50*length(ggsummaryplot)
    ggsummaryfile <- ggsave(paste0(figdir,paste0(traits,collapse="_"),"_summary_plots.pdf"),
                            jointPlots,device="pdf",units="mm",width=175,height=height)
    
    #Save the file locations only. Cat this to log file after colocalisation steps
    ggsummaryfile <- basename(ggsummaryfile)
    
  } else {
    #If written as separate files, save the file locations only
    ggsummaryfile <- basename(unlist(ggsummaryplot))
    
  }
}
######
### Proceed with colocalisation step
######
sink(file = paste0(opt$out,'colocalisation.log'), append = T)
cat("\n######\n### Colocalisation results\n######\n\n")
sink()

#Character vector to flag which coloc analyses have been performed
coloc_performed <- vector(mode="character",length=0L)

#If either SuSiE call failed, a credible set has not been found for both traits, or if analysis is passed direct to coloc, run coloc.abf
if(any(msg1,msg2) || !all(susie1_rep$csFound,susie2_rep$csFound) || opt$runMode %in% c("doBoth","skipSusie")){  
  clc.abf<- coloc.abf(dataset1=sums1.region, dataset2=sums2.region)

  sink(file = paste0(opt$out,'colocalisation.log'), append = T)
  cat("Colocalisation will now be performed without passing first to SuSiE [see coloc::coloc.abf].\n")
  cat("Thus, the single causal variant assumption has not been relaxed.\n")
  cat("coloc.abf was performed with the following priors:\n")
  print(clc.abf$priors)
  cat("coloc.abf results summary:\n")
  print(clc.abf$summary)
  sink()
  
  #Save PP.H4.abf summaries, with additional details to file
  sets_outpath<- paste0(tabdir,"coloc.susie_snpwise_PP_H4_abf.csv")
  
  #Store in plotdata option for potential plotting
  plotdata <- sums1.region %>%
    as.data.frame() %>%
    dplyr::select(snp,pos) %>%
    right_join(clc.abf$results,by="snp")
  
  write.table(plotdata,file=sets_outpath,sep = ",",row.names=FALSE)
  
  sink(file = paste0(opt$out,'colocalisation.log'), append = T)
  cat("\nSNPwise posterior probabilities of being a shared variant for",paste(traits,collapse = " & "),"under coloc.abf are tabulated in:\n", basename(sets_outpath),"\n")
  sink()
  
  #Flag which coloc analysis has been performed 
  coloc_performed <- c(coloc_performed, "coloc.abf")
}

#If both susie calls are successful and credible sets identified, run coloc.susie.
#Note that plots will overwrite any from Coloc.abf.
if(!any(msg1,msg2) && all(susie1_rep$csFound,susie2_rep$csFound) && opt$runMode %in% c("doBoth","trySusie")){
  clc<- coloc.susie(dataset1=susie1, dataset2=susie2) ###Run coloc based on susie outputs

  sink(file = paste0(opt$out,'colocalisation.log'), append = T)
  cat("------------------------------\n")
  cat("coloc.susie was performed with the following priors:\n")
  print(clc$priors)
  invisible(print(clc$summary)) #Call summary invisibly first to avoid triggering bug where no output is printed
  cat("coloc.susie results summary:\n")
  print(clc$summary)
  sink()
  
  credible_snps<- list()
  for(i in 1:nrow(clc$summary)){
    
    #Identify indices to compare
    Index_susie1 <- clc$summary$idx1[i]
    Index_susie2 <- clc$summary$idx2[i]
    
    #Extract SNP names at indices 
    snps1 <- names(susie1$sets$cs[[Index_susie1]])
    snps2 <- names(susie2$sets$cs[[Index_susie2]])
    ####Identify  how SNPs are distributed across the compared sets
    topsnps <- list() 
    topsnps$intersect <- intersect(snps1,snps2)
    topsnps$sus1_only <- snps1[!(snps1 %in% topsnps$intersect)]
    topsnps$sus2_only <- snps2[!(snps2 %in% topsnps$intersect)]
  
    #Label which credible sets are compared
    cs_label <- paste(traits,c(Index_susie1,Index_susie2),sep=":")
    
    #Store in dataframe and assign interpretable values to each SNP
    topsnps <- unlist(topsnps)
    topsnps <- data.frame(cs_susie=gsub("[0-9]+$","", names(topsnps)),
                          snp=unname(topsnps)) %>%
      mutate(cs_susie=case_when(cs_susie=="intersect" ~ paste0(cs_label,collapse = " & "),
                          cs_susie=="sus1_only" ~ cs_label[1],
                          cs_susie=="sus2_only" ~ cs_label[2],
                            TRUE ~ NA_character_),
             cs_susie = as.factor(cs_susie))
    
    credible_snps[[i]]<- topsnps
  }
  
  coloc_performed <- c(coloc_performed, "coloc.susie") #Flag which coloc analysis have been performed 
}


######
### Prepare to plot the results of colocalisation analysis, and write table if coloc.susie is applied
#####

#For plotting, generate labels for SNPs with the top 5% posterior probability of being a shared variant
label_limit <- ceiling(length(snplist)*0.05)

#However, limit the top number of snps to 20 at most 
if(label_limit>10){
  label_limit <- 10
}

toPlot<- list()

if("coloc.abf" %in% coloc_performed){
  
  
  #Colour likely snps under the assumption that h4 is true: " https://chr1swallace.github.io/coloc/articles/a03_enumeration.html
  toPlot[[1]] <- plotdata %>%
    arrange(desc(SNP.PP.H4)) %>%
    mutate(cs_coloc=cumsum(SNP.PP.H4),                                             #Establish coloc.credible set
           thresh=if_else(row_number() <= label_limit, as.character(snp),""), #Label top snps
           #thresh=if_else(cs <= 0.95, as.character(snp),""),                 #Colour those in the 95% CS
           cs_coloc=if_else(cs_coloc <= 0.95, "within set","outside set"),
           cs_coloc= factor(cs_coloc,levels=c("within set","outside set")))
           #cs= as.factor(cs))
}

if("coloc.susie" %in% coloc_performed){
  for(i in 1:nrow(clc$summary)){
    
    #Extract a given plotdata column
    plotdata <- clc$results[,c(1,i+1),with=FALSE]
    #clc_col_index <- which(grepl("SNP.PP.H4",colnames(plotdata)))
    
    #Assign labels to top X% of SNPs, arranged by PP in column
    plotdata<- plotdata %>%
      arrange(desc(.[[2]])) %>%
      mutate(cs_coloc=cumsum(.[[2]]),                                                #Establish coloc.credible set
             thresh=if_else(row_number() <= label_limit, as.character(snp),""), #Label top snps
             #cs_coloc=if_else(cs_coloc <= 0.95, "95% credible set",NA_character_),
             #cs_coloc= as.factor(cs_coloc))
             cs_coloc=if_else(cs_coloc <= 0.95, "within set","outside set"),
             cs_coloc= factor(cs_coloc,levels=c("within set","outside set")))
      
    #Add additional fields to plot data, including SuSiE credible set allocations
    plotdata <- sums1.region %>%
      as.data.frame() %>%
      dplyr::select(snp,pos) %>%
      right_join(plotdata,by="snp") %>%
      full_join(credible_snps[[i]],by="snp")
    
  toPlot[[length(toPlot)+1]] <- plotdata
  }
  
  #Construct results summary table, if there is more than one coloc row, then
  if("coloc.abf" %in% coloc_performed){
    toWrite<- toPlot[[2]]
    start <- 3
  } else {
    toWrite<- toPlot[[1]]
    start <- 2
  }
  if(length(toPlot)>(start-1)){
    for(i in start:length(toPlot)){
      
      if(i==start){
        toWrite_suffix<- c(".row1",".row2")
      } else {
        toWrite_suffix<- c("",paste0(".row",i))
      }
      toWrite <- toWrite %>%
        full_join(toPlot[[i]], by=c("snp","position"),suffix=toWrite_suffix)
      
    }
  }
  
  #Save PP.H4 summaries, with additional details, to file
  sets_outpath<- paste0(tabdir,"coloc.susie_snpwise_PP_H4_abf.csv")
  
  toWrite %>%
    dplyr::select(-which(grepl("thresh",names(.)))) %>%
    write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
  
  sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
  cat("\nSNPwise posterior probabilities of a shared variant for",paste(traits,collapse = " & "),"under coloc.susie are tabulated in:\n", basename(sets_outpath),"\n")
  sink()
}
sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
cat("------------------------------\n")
sink()

######
### Produce plots recurrently across toPlot list
#####
for(i in 1:length(toPlot)){
  
  #Extract plotting dataframe
  clc_col_index <- grep("SNP.PP.H4",colnames(toPlot[[i]]),value = TRUE)
  plotdata<- toPlot[[i]] %>%
    rename(SNP.PP=all_of(clc_col_index))
  
  #Set parameters for loop according to whether a coloc.abf or coloc.susie analysis is being plotted
  if(("coloc.susie" %in% coloc_performed && !"coloc.abf" %in% coloc_performed) ||
     ("coloc.susie" %in% coloc_performed && "coloc.abf" %in% coloc_performed && i!=1)){
    
    #Identify the current analysis, for later logic checks
    current <- "susie"
    
    # #Set colour mapping and legend
    colourMapping = "cs_susie"
    nameColourLegend<- "SuSiE fine-mapping\n(Trait: 95% credible set)"
    
    # #Set shape mapping and legend
    # shapeMapping = "cs_coloc"
    # nameShapeLegend<- "Colocalisation\n(95% credible set\nassuming shared variant)" #Coloc analysis\ncredible set\nassuming a\nshared variant
  
    #Determine filename for loop, first identify which cs are compared, then name accordingly
    if("coloc.abf" %in% coloc_performed){ 
      ind <- i-1
    } else {
      ind <- i
    }
    cs_index<- clc$summary[ind,c("idx1","idx2")]
    cs_label <- paste(traits,cs_index,sep=":")
    cs_filenm <- paste(paste(traits,cs_index,sep="cs"),collapse="_")
    
    filename<- paste0(figdir,"coloc.susie_result_all_snps_",cs_filenm,".pdf")
    
  } else {
    #Identify the current analysis, for later logic checks
    current <- "abf"
    
    # # #Set colour mapping and legend
    colourMapping <- NULL
    nameColourLegend <- NULL
    
    # # #Set colour mapping and legend
    # colourMapping <- "cs_coloc"
    # nameColourLegend <- "Colocalisation\n(95% credible set\nassuming shared variant)"
    # 
    # #Set shape mapping and legend
    # shapeMapping <- NULL
    # nameShapeLegend <- NULL
    # 
    #Determine filename for loop
    cs_filenm <- ".abf"
    filename<- paste0(figdir,"coloc.abf_result_all_snps.pdf")
    
  }
  
  #Set shape mapping and legend
  shapeMapping <- "cs_coloc"
  nameShapeLegend <- "Colocalisation\n(95% credible set\nassuming shared\nvariant)"

  
  #Build all snps plot, add labels for snps
  snp_PP <- ggSummaryplot(yaxis="SNP.PP",
                          xstring="pos",
                          xlim=c(reg_range['start'],reg_range['stop']),
                          dset=plotdata,
                          colourMapping=colourMapping,
                          shapeMapping=shapeMapping,
                          figdir=figdir,
                          traits=traits,
                          returnplot=TRUE,
                          facetTraits = FALSE,
                          nameColourLegend=nameColourLegend,
                          nameShapeLegend=nameShapeLegend,
                          alignment=opt$genomeAlignment) +
    geom_text_repel(aes(label=thresh), max.overlaps = 20, na.rm=TRUE, show.legend = FALSE)
  
  #Saveplot
  ggsave(filename,snp_PP,device="pdf",units="mm",width=150,height=175)
  
  
  #### Replot colocalised snps based on nearby genes
  min_bp<-min(plotdata$pos[plotdata$cs_coloc=="within set"])-gene_window #10KB
  max_bp<-max(plotdata$pos[plotdata$cs_coloc=="within set"])+gene_window #10KB
  chr<- reg_range["chr"]
  
  #Extract genes within the start or stop positions within 
  #Genes_subset<-Genes[Genes$start_position > min_bp & Genes$end_position < max_bp & Genes$chromosome_name == chr,] %>%
  Genes_subset <- Genes[Genes$chromosome_name == chr & (
    (Genes$start_window > min_bp & Genes$start_window < max_bp) |
      (Genes$end_window > min_bp & Genes$end_window < max_bp) |
      (Genes$start_window < min_bp & Genes$end_window > max_bp)
  ),]
  
  #If nearby snps are found, do further plotting, otherwise write message
  if(nrow(Genes_subset)>0){
    
    Genes_subset <- Genes_subset %>%
      arrange(start_position) %>%                      #Sort by start position
      mutate(midpoint=(start_position+end_position)/2, #Determine middle of gene position
             external_gene_name=factor(external_gene_name,levels = rev(external_gene_name[!duplicated(external_gene_name)]))) #Save as factor variable, to maintain sort order
    

    #Save details for nearby genes
    sets_outpath<- paste0(tabdir,"nearby_genes_coloc",cs_filenm,".csv")
    Genes_subset %>%
      dplyr::select(-c(start_window,end_window,midpoint)) %>%
      write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
    
    sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
    
    if(current=="susie"){
      cat("\nGenes located within a 10Kb window around the top 10% of snps from credible sets are tabulated in: ", basename(sets_outpath),"\n")
    } else {
      cat("\nGenes located within a 10Kb window around the top 10% of coloc.abf snps are tabulated in: ", basename(sets_outpath),"\n")
    }
    sink()
    
    #Identify the x axis range based on max and minimum gene windows - plot only genes with a HGNC symbol
    #plot_rng <- c(min(Genes_subset$start_window[Genes_subset$external_gene_source=="HGNC Symbol"]),max(Genes_subset$end_window[Genes_subset$external_gene_source=="HGNC Symbol"]))
    plot_rng <- c(min(c(min_bp,Genes_subset$start_window)),max(c(max_bp,Genes_subset$end_window)))
    
    #Plot nearby genes using a unique plotting approach
    gene_near <- Genes_subset %>%
      filter(external_gene_source=="HGNC Symbol") %>% #only keep HGNC Symbols
      ggplot(.,aes(x=midpoint, y=external_gene_name))+
      geom_errorbar(aes(xmin=start_position,xmax=end_position),width=0.2)+
      #geom_text_repel(aes(label=external_gene_name),fontface="italic",direction="y")+
      xlim(plot_rng)+
      theme_bw()+
      labs(x=paste0("GRCh",opt$genomeAlignment," genomic position (Chr", reg_range["chr"],":",plot_rng[1],"-",plot_rng[2],")"),
           y="Nearby genes")+
      theme(axis.text.y = element_text(face="italic"))

    
    #Narrow the snp plot xlim to match gene_near
    suppressMessages({ #Suppress warning about 'double-setting' xlim
      snp_PP_range <- snp_PP +
        xlim(plot_rng)
    })
    
    #If susie has been plotted, colouring is used to label Susie credible sets, adjust legend to include only snps in the new plot range
    if(current=="susie"){ 
      #To ensure consistent colouring when reassigning the colour factor, assign factor levels to specific colours
      levels<- levels(plotdata[[colourMapping]])
      col_levels <-ggpalette[1:length(levels)]
      names(col_levels)<- levels
      
      suppressMessages({ #Suppress warning about redoing existing legend
        snp_PP_range <- snp_PP_range +
          scale_colour_manual(na.value = "black", values=col_levels,
                              breaks = levels(droplevels(plotdata[which(plotdata$pos > plot_rng[1] & plotdata$pos < plot_rng[2]),colourMapping])))
      })
    }
    
    #Scale plot proportions according to number of genes plotted, but cap at 1, indicating equal proportions
    propor <- 0.05*length(gene_near$data$external_gene_name)
    if(propor>1){propor <- 1}
    
    g_arr <- egg_ggarr_wlegend(list(snp_PP_range,gene_near),position = "right",ncol=1,heights=c(1,propor))
    
    #If plotting the result of coloc.susie analysis, add extra info relevant to credible set assignments 
    if(current=="susie"){
      filename<- paste0(figdir,"coloc_susie_likely_snps_with_genes",cs_filenm,".pdf")
      
    } else {
      filename<- paste0(figdir,"coloc_abf_likely_snps_with_genes.pdf")
    }
    
    ggsave(filename,g_arr,device="pdf",units="mm",width=150,height=175)
    
  } else { #Conditional statement for when no nearby genes are found
    
    sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
    
    if(("coloc.susie" %in% coloc_performed && !"coloc.abf" %in% coloc_performed) ||
       ("coloc.susie" %in% coloc_performed && "coloc.abf" %in% coloc_performed && i!=1)
    ){
      cat("\nNo genes were identified within a 10Kb window around snps from the current credible sets comparison:",gsub("_"," & ",cs_filenm),".\n")
    } else {
      cat("\nNo genes were identified within a 10Kb window around the top 10% of coloc.abf snps.\n")
    }
    sink()
    
  }
  
} 

sink(file = paste(opt$out,'colocalisation.log',sep=''), append = T)
cat("------------------------------\n")
sink()



#Write to log which GWAS summary plots have been written
sink(file = paste0(opt$out,'colocalisation.log'), append = T)
cat("Selected graphical comparison between summary statistics has been written to the file(s):\n",
    paste0(ggsummaryfile,sep="\n"),"\n")
sink()
