#####
# Author: Thomas Spargo (thomas.spargo@kcl.ac.uk)
# Obtained from GitHub repository: https://github.com/ThomasPSpargo/COLOC-reporter
#
# This script performs colocalisation analysis between two traits at a specified genomic region. 
# Preprocessing and finemapping are handled per-trait and colocalisation analysis is performed with the COLOC software, either using coloc.abf or coloc.susie.
#####
suppressPackageStartupMessages(library(optparse))

option_list = list(
  
  #General options
  make_option("--LAVAfile", action="store", default=NA, type='character',
              help='Path to bivariate genetic correlation summary generated by LAVA. The script extract the locus with the smallest p-value by default. To analyse other genomic regions use the --set_locus option. If --set_locus specifies a comma separated genomic region directly list of the format "chromosome,start_position,end_position" (e.g. 17,43460501,44865832) then no --LAVAfile is required.'),
  make_option("--plink", action="store", default='plink', type='character',
              help="Path to PLINK executable (syntax written for PLINK 1.9). By default, has the value 'plink'"),
  make_option("--traits", action="store", default=NULL, type='character',
              help="Comma separated list of IDs for traits to analyse (e.g. 'P1,P2'), as relevant to the summary statistics defined in the  --GWASconfig input file."),
  make_option("--set_locus", action="store", default=NA, type='character',
              help='Specify target locus to test, either as a number referring to a locus from --LAVAfile, or as a comma separated list of the format "chromosome,start_position,end_position" (e.g. 17,43460501,44865832).'),
  make_option("--LDreference", action="store", default=NA, type='character',
              help="Path to, and prefix for, per-chromosome PLINK binary files used to compute LD matrix for SNPs in region. This input is used by SuSiE. Expected format of <prefix>i.bim, where i is the chromosome number"),
  make_option("--GWASconfig", action="store", default=NULL, type='character',
              help="Path to file specifying configuration of GWAS sumstats. Configuration will be determined by identifying rows whose IDs match the --traits option."),
  make_option("--runMode", action="store", default="trySusie", type='character',
              help="Character string, any of 'trySusie', 'skipSusie', 'doBoth','finemapOnly'.\nIf 'doBoth', both coloc.abf and coloc.susie will attempt to run.\nIf 'trySusie' coloc.susie will be used if SuSiE finemapping identifies at least 1 credible set in each trait and coloc.abf is returned otherwise.\nIf 'skipSusie', only coloc.abf will be applied, and processes necessary for coloc.susie are skipped (e.g. no need to call to plink and generate LD matrix); the LD reference will however still still used for SNP alignment.\nIf 'finemapOnly' then univariate finemapping is performed which can be applied across any number of traits. Note however that only snps in common across all traits and the reference panel will be retained. Therefore, for colocalisation analysis it may be preferable to harmonise summary statistics used in colocalisation analysis pairwise."),
  make_option("--force_matrix", action="store", default=FALSE, type='logical',
              help="If TRUE, the LD matrix will always be recomputed using PLINK. If FALSE, the default, the LD matrix will only be computed if the expected ld_matrix.snplist and ld_matrix.ld files are absent from the <output>/LDmatrix directory."),
  make_option("--out", action="store", default="./COLOC-reporter", type='character',
              help="Path and prefix for directory in which to return all outputs. Defaults to ./COLOC-reporter. When running multiple analyses, unique output directories are essential for tidy file organisation."),
  make_option("--GWASsumplots", action="store", default="p", type='character',
              help="Comma separated string with any combination of 'PIP','p','z','beta'; defaults to 'p'. Generate ggplots comparing summary statistic results on named statistic for both traits. See also the associated --GWASsumplots_onefile --GWASsumplots_incfinemapping options. PIP refers to posterior inclusion probabilities for snps as indicated from SuSiE"),
  make_option("--GWASsumplots_onefile", action="store", default=FALSE, type='logical',
              help="Logical, defaults to FALSE. When --GWASsumplots has more then one element, indicate TRUE to return all comparisons bound into a single figure; plots will be stacked vertically, in the order of the --GWASsumplots vector."),
  make_option("--GWASsumplots_incfinemapping", action="store", default=TRUE, type='logical',
              help="Logical, defaults to TRUE. If TRUE, and if any credible sets are identified across the two traits, plots returned by --GWASsumplots will include colouring indicating (if any) the finemapping credible sets assigned to each snp."),
  make_option("--genomeAlignment", action="store", default=37, type='numeric',
              help="Indicate the reference genome to which summary statistics and LD reference are aligned. Defaults to 37."),
  make_option("--gene_tracks", action="store", default=NULL, type='numeric',
              help="Numeric. Specify the threshold at which plotting of nearby genes changes from one gene per row to plotting multiple genes across individual rows, labelling genes with geom_text_repel. Defaults to NULL, where per-row plotting has no upper limit. Specify 1 to always plot multiple genes per row, provided their genomic positions do not overlap [work in progress]."),
  make_option("--restrict_nearby_gene_plotting_source", action="store", default=NULL, type='character',
              help="Comma delimited character string indicating sources from which nearby genes included in plots are retrieved. Check output tables 'external_gene_source' column for options. Included as an option to reduce overplotting of obscure gene symbols. If NULL, the default, all sources will plot"),
  make_option("--helperFunsDir", action="store", default=NULL, type='character',
              help="Filepath to directory containing helper functions used within the script")
)

opt = parse_args(OptionParser(option_list=option_list))

#######
### Begin script
#######

suppressPackageStartupMessages({
  library(tidyverse)
  library(data.table) #To read in the datasets
  library(R.utils)    #Required reading gz files directly with fread
  library(coloc)
  library(susieR)
  library(biomaRt)    #For ensembl library
  library(ggrepel)
  library(egg)     #arranging summary plot
})

test <- FALSE # test <- TRUE
if(test==TRUE){
  #####
  setwd("/Users/tom/OneDrive - King's College London/PhD/PhD project/COLOC/git.local.COLOC-reporter/testing")
  opt <- list()
  
  # # #TESTING V3
   opt$set_locus <- "17,43460501,44865832"
  opt$GWASconfig <- "./GWAS_samples_testing.txt"
  opt$out <- "./tidy_processingTEST_PD.SZ.chr17"
  opt$traits <- "PD,SZ,ALS"
  
  opt$LDreference <- './EUR_phase3_chr'
  opt$runMode <- 'doBoth'
  opt$force_matrix <- FALSE
  
  opt$gene_tracks <- 40
  opt$restrict_nearby_gene_plotting_source <- "HGNC Symbol"
  opt$genomeAlignment <- 37
  
  opt$helperFunsDir <- "/Users/tom/OneDrive - King's College London/PhD/PhD project/COLOC/git.local.COLOC-reporter/scripts/helper_functions"
  
  opt$GWASsumplots <- c("PIP,p,beta")
  opt$GWASsumplots_onefile <- FALSE
  opt$GWASsumplots_incfinemapping <- TRUE
  
}

#Extract names of traits compared, first dropping file path, and then any prefixes indicated by a preceding underscore
traits <- strsplit(opt$traits,",")[[1]]

#Read in the configuration options
GWASconfig<- fread(opt$GWASconfig)
Config_msg <- paste0("Summary statistic configuration options set according to the specification of --GWASconfig for trait IDs: ", paste0(1:length(traits)," = ",traits,collapse = ", "),".\n",sep='')

#Assign names to traits
names(traits) <- GWASconfig[traits,on="ID"]$traitLabel

opt$out <- paste0(opt$out,"_coloc")
if(!dir.exists(opt$out)){dir.create(opt$out,recursive = TRUE)}

#Set up directories in which to return tables and figures
figdir <- file.path(opt$out,"plots")
if(!dir.exists(figdir)){dir.create(figdir)}
tabdir <- file.path(opt$out,"tables")
if(!dir.exists(tabdir)){dir.create(tabdir)}
datadir <- file.path(opt$out,"data")
if(!dir.exists(datadir)){dir.create(datadir)}


logfile <- file.path(opt$out,'colocalisation.log')

#Setup a colour palette to be used across ggplots (colours taken from plot SuSiE)
ggpalette = c("dodgerblue2", "green4", "#6A3D9A", "#FF7F00", 
              "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", 
              "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", 
              "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", 
              "yellow3", "darkorange4", "brown")

#Function to scale x-axis based on plot range
xScaler <- function(range){
  #Rescale x-axis into MBs or KBs
  if(range>100000){
    xscale <- 1000000
    xscale_magnitude <- " [Mb]"
  } else if (range>100) {
    xscale <- 1000
    xscale_magnitude <- " [Kb]"
  } else {
    xscale <- 1
    xscale_magnitude <- ""
  }
  return(list(xscale=xscale,xscale_magnitude=xscale_magnitude))
}


sink(file = logfile, append = F)
cat(
  '#################################################################
# colocaliseRegion.R
# Perform colocalisation analysis between GWAS summary statistics in a predetermined genomic region.
# Colocalisation leverages the COLOC and SuSiE software packages.
# Genetic regions must either identified manually or can be selected based on output from LAVA software.
# Documentation for options for running the script can be called with: Rscript ./colocaliseRegion.R --help
# 
# This script was written by Thomas Spargo (thomas.spargo@kcl.ac.uk), please get in touch with any queries.
#
#################################################################
Analysis started at',as.character(Sys.time()),'\n',Config_msg,'Options are:\n')
print(opt)

cat("\n######\n### Setup\n######\n\n")

cat("All outputs will be returned in the directory: ", opt$out,"\n")
cat("All figures are returned in the subdirectory: ",basename(figdir),"\n")
cat("with tabular summaries in the subdirectory: ",basename(tabdir),"\n")
cat("and .Rds files with resources from each main analysis step in the subdirectory: ",basename(datadir),"\n\n")

sink()

#Read-in custom helper functions stored in directory specified by opt$helperFunsDir
list.files(opt$helperFunsDir,full.names = TRUE,pattern=".R") %>%
  lapply(.,source) %>%
  invisible(.)

if(length(opt$GWASsumplots)>0){
  #Parse the comma delimited list
  opt$GWASsumplots <- strsplit(opt$GWASsumplots,",")[[1]]
  
  #Return warning if any of the gwas summary plot options are not recognised, then drop the unrecognised elements
  checksumplots<- tolower(opt$GWASsumplots) %in% c('pip','p','z','beta')
  if(any(!checksumplots)){
    sink(file = logfile, append = T)
    cat("WARNING: The --GWASsumplots option contained unrecognised strings which have been dropped. Please indicate any combination of 'pip', 'p', 'z', 'beta', case-insensitive)")
    sink()
    
    opt$GWASsumplots <- opt$GWASsumplots[-which(checksumplots)] #Drop the unrecognised strings
  }
}

  
######
### Import datasets
######
#Import datasets and convert to tibbles
sums <- lapply(GWASconfig[traits,on="ID"]$FILEPATH,function(x){tibble(fread(x))})
names(sums) <- traits

#Loop across traits to test whether columns identified match those indicated in the config file
colcheck<- mapply(function(x,trait){
  #Check for column name options match the dataset, warn if not
  colcheck <-  which(!(
    c(GWASconfig[trait,on="ID"]$p_col,
      GWASconfig[trait,on="ID"]$stat_col,
      GWASconfig[trait,on="ID"]$N_col,
      GWASconfig[trait,on="ID"]$chr_col,
      GWASconfig[trait,on="ID"]$pos_col,
      GWASconfig[trait,on="ID"]$se_col,
      GWASconfig[trait,on="ID"]$snp_col,
      GWASconfig[trait,on="ID"]$freq_col)
    %in% colnames(x)
  ))
  return(colcheck)
},x=sums,trait=traits)

colProblem<- sapply(colcheck,length)>0
if(any(colProblem)){
  sink(file = logfile, append = T)
  warning("The column names expected based on the --GWASconfig options set for trait(s): ", paste0(names(colProblem)[colProblem],collapse=", "), " do not match columns detected in the file. Please check the option(s) specified.")
  sink()
}

#Adjust column names into COLOC format.
#mapply is set to SIMPLIFY=FALSE to ensure a list result
sums<- mapply(function(x,trait){
  #Unless specified to be an odds ratio, rename as beta
  if(GWASconfig[trait,on="ID"]$stat_col=="OR"){
    x$beta <- log(x$OR)
    x$OR <- NULL
  } else {
    names(x)[names(x)==GWASconfig[trait,on="ID"]$stat_col] <- "beta"
  }
  
  #Rename the other columns  
  names(x)[names(x)==GWASconfig[trait,on="ID"]$p_col] <- "pvalues"
  names(x)[names(x)==GWASconfig[trait,on="ID"]$N_col] <- "N"
  names(x)[names(x)==GWASconfig[trait,on="ID"]$chr_col] <- "chr"
  names(x)[names(x)==GWASconfig[trait,on="ID"]$pos_col] <- "pos"
  names(x)[names(x)==GWASconfig[trait,on="ID"]$se_col] <- "SE"
  names(x)[names(x)==GWASconfig[trait,on="ID"]$snp_col] <- "snp"
  names(x)[names(x)==GWASconfig[trait,on="ID"]$freq_col] <- "MAF"
    
  return(x)
},x=sums,trait=traits,SIMPLIFY=FALSE)


########
#### Identify region for analysis
########
if(!is.na(opt$set_locus)){
  
  opt$set_locus <- as.numeric(strsplit(opt$set_locus,",")[[1]])
  
  if(length(opt$set_locus)==3){
    #Set genomic positions manually
    reg_range <-c(chr=opt$set_locus[1],
                   start=opt$set_locus[2],
                   stop=opt$set_locus[3])
    
  } else if(length(opt$set_locus)!=1) {
    stop('The option --set_locus is defined but cannot be identified as specifying a genomic region manually (in the comma separated format "chromosome,start_position,end_position") or as single numeric referring to local genetic correlation locus from LAVA')
  } else {
    
    if(is.na(opt$LAVAfile)){
      stop('please set the option --LAVAfile when passing a single numeric in the --set_locus option; this numeric refers to the genomic region flagged by the locus number from LAVA.\n\nNote that --set_locus also accepts a manually defined genomic region (in the comma separated format "chromosome,start_position,end_position"), and the --LAVAfile option is ignored in this circumstance')
    }
    
    #Read the lava input, and extract the locus named
    LAVAfile <- tibble(fread(opt$LAVAfile))
    LAVAregion <- which(LAVAfile$locus==opt$set_locus)
    
    reg_range <-c( chr=LAVAfile$chr[LAVAregion],
                   start=LAVAfile$start[LAVAregion],
                   stop=LAVAfile$stop[LAVAregion])
  }
} else {
  #Read the lava input, and extract the locus with the smallest p-value
  LAVAfile <- tibble(fread(opt$LAVAfile))
  LAVAregion <- which(LAVAfile$p==min(LAVAfile$p))
  
  reg_range <-c( chr=LAVAfile$chr[LAVAregion],
                 start=LAVAfile$start[LAVAregion],
                 stop=LAVAfile$stop[LAVAregion])
}

target_region <- paste0("chr",reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"])

sink(file = logfile, append = T)
cat(paste0("Colocalisation analysis will be performed for the region: ", target_region," \n"))
sink()

######
# Harmonise summary statistics with reference
######

# Define function to flip sumstat direction to match alleles across gwas and reference,
# Allele frequency is not reversed since coloc utilises MAF.
alignSS <- function(ss,bim){
  ss_bim_match<-merge(ss, bim, by.x=c('snp','A1','A2'), by.y=c('V2','V5','V6'))
  ss_bim_swap<-merge(ss, bim, by.x=c('snp','A1','A2'), by.y=c('V2','V6','V5'))
  
  ss<-ss[ss$snp %in% ss_bim_match$snp | ss$snp %in% ss_bim_swap$snp,] 
  ss$beta[ss$snp %in% ss_bim_swap$snp] <- -ss$beta[ss$snp %in% ss_bim_swap$snp]
  
  return(ss)
}

# Read in reference SNP data to match alleles 
bim<-fread(paste0(opt$LDreference,reg_range["chr"],'.bim'))

#Return total snps available
snpsavail<- lapply(sums,function(x){
  y <- x[x$chr==reg_range["chr"] &
         x$pos>=reg_range["start"] &
         x$pos<=reg_range["stop"],]
  nrow(y)})
sink(file = logfile, append = T)
cat("Total number of SNPs for each sumstats in tested region:\n", paste0(names(snpsavail)," = ",snpsavail,collapse = "\n"),"\n\n",sep='')
sink()
rm(snpsavail)

#Filter to snps in the define chromosome:position range and present in the LD reference data
#Mutate to calculate minor allele frequency and varbeta.
sums.region <- lapply(sums, function(x){
  x %>%
    filter(chr==reg_range["chr"],
           pos>=reg_range["start"],
           pos<=reg_range["stop"],
           snp %in% bim[["V2"]]
    ) %>%
    arrange(match(snp, bim[["V2"]])) %>%
    mutate(MAF=if_else(MAF>0.5,1-MAF,MAF),
           varbeta = SE^2) %>%
    alignSS(.,bim)
    
})

#Return snps available after harmonising with sumstats
snpsavail<- lapply(sums.region,nrow)
sink(file = logfile, append = T)
cat("Number of SNPs in common between LD reference and each set of sumstats in tested region:\n", paste0(names(snpsavail)," = ",snpsavail,collapse = "\n"),"\n",sep='')
sink()
rm(snpsavail)

#Intersect the snp lists to find those common across traits
snplist <- Reduce(intersect,lapply(sums.region,function(x){x$snp}))
sink(file = logfile, append = T)
#Print some information to console
cat(paste0("N SNPs in common across traits after harmonising to LD reference: ", length(snplist),"\n"))
if(length(snplist)==0){cat("Analysis stopped as no SNPs remain.\n");stop("Analysis stopped as no SNPs remain.")}
sink()



#Intersect the overlapping SNPs, and assign sequence position in common snp sequence (based on rownumber).
sums.region <- lapply(sums.region, function(x){x %>%
    filter(snp %in% snplist) %>%
    mutate(position = row_number())
})

snpid<- lapply(sums.region,function(x){paste0(x$snp,"_",x$pos)})
#Return warning if the SNP position alignment seems incorrect.
#sapply compares for identical results across all vectors relative the first vector
if(!all(sapply(snpid[-1],identical, snpid[[1]]))){
  sink(file = logfile, append = T)
  cat("WARNING: SNP names and genomic positions do not match between all datasets. Please check that these have been aligned correctly.")
  sink()
}
rm(snpid)

######
# Generate LD matrix (for SuSiE)
######

if(opt$runMode %in% c("trySusie", "doBoth","finemapOnly")){
  #Extract snps and write list to file in subdirectory of results directory
  
  #Check for the expected LD matrix output; if files are absent or if --force_matrix is set, generate using PLINK
  expect <- c(".snplist",".ld")
  expect <- file.path(opt$out,'LDmatrix',paste0('ld_matrix',expect))
  
  if(any(!file.exists(expect)) | opt$force_matrix){
    
    sink(file = logfile, append = T)
    cat("Computing LD matrix...")
    sink()
    
    ld_dir<- dirname(expect[1])
    
    if(!dir.exists(ld_dir)){dir.create(ld_dir,recursive = TRUE)}
    write(snplist, file=file.path(ld_dir,"snplist.txt"))
    
    #Identify LD matrixsnps from snplist present in reference
    #Syntax based on plink v 1.9
    system(paste0(opt$plink,' --bfile ', opt$LDreference,reg_range["chr"],
                  ' --extract ',ld_dir,'/snplist.txt',
                  ' --r square',
                  ' --write-snplist',
                  ' --keep-allele-order',
                  ' --out ',file.path(ld_dir,'ld_matrix')))
    
    sink(file = logfile, append = T)
    cat("Done\n")
    sink()
    
  } else {
    sink(file = logfile, append = T)
    cat("Existing LD matrix found, skipping call to PLINK.\n")
    sink()
  }
  
  #Read in the ld matrix and snp names as returned by plink 
  ld <- as.matrix(fread(expect[2]))
  ld_names<- scan(expect[1],what=character())
  dimnames(ld)<-list(ld_names, ld_names) #assign dimnames to LD object
  
  #As a sanity check, redo alignment based on plink output order to ensure snps are correctly arranged in base pair order, and assign 'positions' for coloc
  sums.region <- lapply(sums.region, function(x){
    x %>%
      filter(snp %in% ld_names) %>%
      arrange(match(snp, ld_names)) %>%
      mutate(position = row_number())
  })
} 

######
# If doing summary plotting, extract a minimal combination of statistics from the harmonised datasets
# this will be used in plotting after attempting finemapping step
######
if(length(opt$GWASsumplots)>0){
  minimal_P1P2_df<- mapply(function(x,trait,keepcols){cbind(x[,keepcols],trait)
  },sums.region,traits,
  MoreArgs=list(keepcols=c("snp","pos","beta","SE","pvalues")), SIMPLIFY = FALSE) %>%
    do.call(rbind,.) 
}

######
### Prepare for colocalisation analysis; convert each data.frame to list and add expected list elements
######

##Expected elements:
#LD matrix (if passing via SuSiE)
#type = "cc" or "quant" depending on trait type
#s = case control proportion if "cc"
#Adjust column names into COLOC format.
#mapply is set to SIMPLIFY=FALSE to ensure a list result
sums.region<- mapply(function(x,trait){
  
  x <- as.list(x)
  x$type <- tolower(GWASconfig[trait,on="ID"]$type)
  if(x$type=="cc"){x$s <- GWASconfig[trait,on="ID"]$prop
  } else if(x$type=="quant" && !is.na(GWASconfig[trait,on="ID"]$traitSD)){x$sdY <- GWASconfig[trait,on="ID"]$traitSD}
  if(opt$runMode %in% c("trySusie", "doBoth","finemapOnly")){x$LD <- ld}
  
  #Save the formatted dataset as a resource
  datasetpath<- file.path(datadir,"datasets")
  if(!dir.exists(datasetpath)){dir.create(datasetpath)}
  saveRDS(x,file=file.path(datasetpath,paste0("harmonised_dataset_",trait,".Rds")))
  
  return(x)
},x=sums.region,trait=traits,SIMPLIFY=FALSE)

######
### Extract genes around tested region
######

#Import gene information for region
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=opt$genomeAlignment)
Genes<-getBM(attributes=c('external_gene_name','chromosome_name','start_position','end_position','external_gene_source','strand'), mart = ensembl)

# Use 10kb window to define gene window
gene_window<-10000
Genes$start_window<-Genes$start_position-gene_window
Genes$end_window<-Genes$end_position+gene_window

# Do main Susie steps
if(opt$runMode %in% c("trySusie", "doBoth","finemapOnly")){
  
  #Run SuSiE across datasets and generate report summaries
  #A guideline for N is specified since this is highly recommended
  
  SusieFail <- logical(0) #SusieFail indicates if susie was successful across traits: TRUE indicates an error was thrown
  susie <- mapply(function(dset,trait){
    tryCatch({
      #Run Susie
      finemap<- runsusie(dset,n=max(dset$N))
      
      #Save the susie results as a resource
      finemappath<- file.path(datadir,"finemapping")
      if(!dir.exists(finemappath)){dir.create(finemappath)}
      saveRDS(finemap,file=file.path(finemappath,paste0("susie_results_",trait,".Rds")))
      
      #Assign FALSE if errors weren't thrown
      assign("SusieFail",c(SusieFail,FALSE),envir=.GlobalEnv)
      
      return(finemap)},
      
      error   = function(x){ #If there is an issue, flag in global environment and print to log file
        warning(x)
        assign("SusieFail",c(SusieFail,TRUE),envir=.GlobalEnv)
        
        sink(file = logfile, append = T)
        cat("------------------------------\n")
        cat("SuSiE fine-mapping error produced for", traits[length(SusieFail)],". Please see the following:\n")
        cat("Error in", toString(last.warning),":\n",names(last.warning),"\n")
        cat("------------------------------\n")
        sink()
      })
  },sums.region,traits,SIMPLIFY = FALSE)
  
  sink(file = logfile, append = T)
  cat("\n######\n### SuSiE fine-mapping results\n######\n\n")
  sink()
  
  ######
  ### Summarise susie results across datasets
  ######
  susie_rep <- mapply(function(susie.fit,basedata,trait,failed){
    
    if(failed){ #For a trait with a failed finemapping step, terminate early and return empty list for downstream logic-checks
      return(list(csFound=FALSE,sets=data.frame(snp=snplist,cs=factor(NA_character_),
                                                              variable_prob=NA_real_)))
    } else { #Otherwise, produce a summary!
    
    #Drop the list elements of basedata which cannot be converted to a dataframe, and then convert
    basedata$s <- basedata$type <- basedata$LD <- basedata$sdY <- NULL
    basedata <- as.data.frame(basedata)
    
    sum_susie <- summary(susie.fit)
    csFound<- !is.null(sum_susie$cs) #Logical statement to pass through indicating TRUE if a CS has been identified
    
    ##### Generate summary table for PIP of SNPs
    sets<- sum_susie$vars #[sum_susie$vars$cs!=-1,] #Extract all snps
    sets<- cbind(sets,basedata[sets$variable,c("snp","chr","pos","pvalues","beta","SE")]) #Add relevant columns from GWAS sumstats
    
    #Save PIP summaries to file
    sets_outpath<- file.path(tabdir,paste0("susie_snp_summary_",trait,".csv"))
    write.table(sets,file=sets_outpath,sep = ",",row.names=FALSE)
    tab_out<- paste0("PIP summaries for SNPs for ",trait," are tabulated in:\n", basename(sets_outpath),"\n") #Info string
    
    ### Plot the pip summaries alongside snp p-values
    
    #Mutate data for plotting
    sets <- sets %>%
      mutate(cs = if_else(cs==-1,NA_real_,cs),
             cs = as.factor(cs),
             thresh = if_else(!is.na(cs),as.character(snp),""))
    
    if(csFound){ #if CS are found
      colourMapping <- "cs" #Dynamically set colour attribute 
      
      #Replicate Susie plot legend labelling
      CSlen<- sapply(susie.fit$sets$cs,length)
      CSmin<- susie.fit$sets$purity$min.abs.corr
      levels(sets$cs) <- paste0(names(susie.fit$sets$cs),": C=",CSlen,"/R=",round(CSmin,3))
      
    } else {
      colourMapping <- NULL
    }
    
    #Use trait name as plot title if possible
    if(!is.null(names(trait))){
      title <- names(trait)
    } else {
      title <- trait
    }
    
    #Supply string-based aesthetic elements via list
    aesthetics<- list(colour=colourMapping) %>%
      lapply(., function(x) if (!is.null(x)) sym(x))
    
    xScale<- xScaler(reg_range[["stop"]]-reg_range[["start"]])
    
    pips<- ggplot(sets,aes(x=pos,y=variable_prob,!!!aesthetics))+
      geom_point() +
      theme_bw()+
      theme(plot.title = element_text(hjust=0.5))+
      scale_x_continuous(breaks = scales::breaks_extended(n=4), 
                         labels=scales::label_number(scale = 1 / xScale$xscale,accuracy = 0.1) #Scale axis magnitude dynamically
      )+ 
      labs(y="PIP",x=paste0("GRCh",opt$genomeAlignment," genomic position (",target_region,")",xScale$xscale_magnitude),title=title)
    
    #Add colours to plots if a credible set has been identified
    if(!is.null(colourMapping)){
      pips <- pips +
        scale_colour_manual(na.value = "black", values=ggpalette,breaks=levels(sets$cs))+
        guides(color=guide_legend(title="Credible set"))
    }
    
    ggsave(file.path(figdir,paste0("susie_PIP_",trait,".pdf")),pips,device="pdf",units="mm",width=150,height=150)
    
    if(csFound){
      ##### Create summary file    
      finemap_summary <- data.frame(CS_span = NA,
                                    beta_maxSNP = basedata$snp[which(basedata$beta==max(basedata$beta))],
                                    p_minSNP = basedata$snp[which(basedata$pvalues==min(basedata$pvalues))],
                                    TopPIPsnp = NA,
                                    sum_susie$cs,
                                    NSNP=NA,
                                    TopPIP=NA,
                                    Genes_near_span=NA)
      
      for(j in 1:nrow(sum_susie$cs)){
        snp_index<-as.numeric(unlist(strsplit(finemap_summary$variable[j], ',')))
        
        finemap_summary$NSNP[j] <- length(snp_index)
        finemap_summary$TopPIP[j]<-max(susie.fit$pip[snp_index])
        finemap_summary$TopPIPsnp[j]<- paste(names(susie.fit$pip)[susie.fit$pip==finemap_summary$TopPIP[j] & seq_along(susie.fit$pip) %in% snp_index], collapse=', ')
        
        ss_subset<-basedata[(basedata$snp %in% names(susie.fit$pip)[snp_index]),]
        min_bp<-min(ss_subset$pos)
        max_bp<-max(ss_subset$pos)
        chr<-ss_subset$chr[1]
        
        finemap_summary$CS_span[j]<- paste0("chr",chr,":",min_bp,"-",max_bp) #span of credible set
        
        Genes_subset<- Genes[Genes$chromosome_name == chr & (
          (Genes$start_window >= min_bp & Genes$start_window <= max_bp) | #Test if start position is within range
            (Genes$end_window >= min_bp & Genes$end_window <= max_bp) |   #or if end position is within range
            (Genes$start_window <= min_bp & Genes$end_window >= max_bp)   #or if start and end positions are both outside range [gene straddles window]
        ),]
        
        if(nrow(Genes_subset) > 0){
          #Write the gene names
          finemap_summary$Genes_near_span[j]<-paste(Genes_subset$external_gene_name, collapse=', ')
          
          #Save details for genes near to credible set #NO MENTION OF THIS OUTPUT IN THE REPORT
          sets_outpath<- file.path(tabdir,paste0("nearby_genes_",trait,"_cs",j,".csv"))
          Genes_subset %>%
            dplyr::select(-c(start_window,end_window)) %>%
            write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
        }
      }
      finemap_summary$variable <- NULL
      
      #Write finemapping summary to a file and concatenate with previous results if file already exists
      finemapSummary<- file.path(tabdir,"results_summary_finemapping.csv")
      write.table(cbind(trait=unname(trait),finemap_summary),
                  file=finemapSummary,sep = ",",row.names=FALSE,col.names = !file.exists(finemapSummary),append = file.exists(finemapSummary))
      
    } else {
      finemap_summary <- "No 95% confidence credible sets could be identified"
    }
    
    #Sink directly to file
    sink(file = logfile, append = T)
    cat("------------------------------\n")
    cat("SuSiE finemap result for", trait,":\n")
    print(finemap_summary)
    cat("\n",tab_out)
    cat("------------------------------\n")
    sink()
    
    #Return results just in case
    return(list(finemap_summary=finemap_summary,tab_out=tab_out,csFound=csFound, sets=sets))
    }
  },susie,basedata=sums.region,trait=traits,failed=SusieFail,SIMPLIFY = FALSE)
  
  
  if(file.exists(file.path(tabdir,"results_summary_finemapping.csv"))){
    sink(file = logfile, append = T)
    cat("\nSummaries of credible sets identified by susie across traits are all available in the file: results_summary_finemapping.csv\n")
    sink()
  }
  
  
  #Flag either of the SuSiE calls failed
  if(any(SusieFail)){
    
    ######
    ### Check alignment of Beta and LD, may lead to issues with LD matrix convergence if not aligned in the same direction
    ######
    pdf(file=file.path(figdir,"Beta_LD_alignment.pdf"),width=7,height=7)
    lapply(sums.region,check_alignment)
    dev.off()
    
    sink(file = logfile, append = T)
    cat("The SuSiE finemapping step returned an error for at least one trait (see above).\n")
    cat("Figures have been generated in 'Beta_LD_alignment.pdf', check these to compare alignment of summary statistic betas and the LD matrix.\nSee https://chr1swallace.github.io/coloc/articles/a02_data.html for details.\n")
    sink()
    
  } else if(!all(sapply(susie_rep[1:2],function(x)x$csFound))){ #Return this message on the basis of only the first two traits
    sink(file = logfile, append = T)
    cat("Credible sets were not identified for at least one trait, therefore coloc.susie cannot be utilised.\n")
    sink()
  }
} else {
  #If susie is skipped entirely, produce some dummy values required for subsequent logic checks
  susie_rep <- sapply(seq_along(sums.region),function(x){
    list(csFound=FALSE, sets=data.frame(snp=snplist,
                                        cs=factor(NA_character_),
                                        variable_prob=NA_real_))
  })
    
  SusieFail <- sapply(seq_along(sums.region),function(x) FALSE)
  
}

######
### Prepare for, and then generate Summary plots comparing the region-results for the two GWAS
######
if(length(opt$GWASsumplots)>0){
  
  #Extract PIPs for each trait 
  snp_PIP <- mapply(function(x,trait,keepcols){cbind(x$sets[,keepcols],trait)
    }, susie_rep, traits,
    MoreArgs=list(keepcols=c("snp","variable_prob")), SIMPLIFY = FALSE) %>%
      do.call(rbind,.) 
  
  #Combine SuSiE PIP results with the minimal dataset
  minimal_P1P2_df <- minimal_P1P2_df %>%
    full_join(snp_PIP,by=c("snp","trait"))  #add each PIP
  
  #According to whether any CS have been found, add a CS column to the dataframe
  if(any(sapply(susie_rep,function(x)x$csFound))){
    
    #Extract credible set summaries per-snp across traits.
    #Subset to columns, adjust credible set labels, then reduce list across matched DFs and unite cols
    snp_CS<- mapply(function(x,trait){ 
      y <- x$sets[,c("snp","cs")]
      if(length(levels(y$cs))>0){levels(y$cs) <- paste0(trait,":",gsub("^L([0-9]+)\\:.*","\\1",levels(y$cs)))}
      return(y)
      },susie_rep,traits,SIMPLIFY = FALSE) %>%
      reduce(full_join,by="snp") %>%
      tidyr::unite(.,col=cs, starts_with("cs"), sep = " & ", remove = TRUE, na.rm = TRUE) %>%
      mutate(cs=as.factor(if_else(cs=="",NA_character_,cs)))
      
    #Combine SuSiE credible sets with the minimal dataset
    minimal_P1P2_df <- full_join(minimal_P1P2_df,snp_CS,by="snp")

    colourMapping <- "cs" #Set colour attribute 
  } else {
    # #If no SuSiE, assign an empty column
    minimal_P1P2_df$cs <- NA_character_
    
    colourMapping <- NULL #Set colour attribute 
  }
  
  #If not including finemapping, override colourmapping and set to null
  if(opt$GWASsumplots_incfinemapping==FALSE){
    colourMapping <- NULL
  }
  
  
  #Dynamically plot gwas stat summary figures, varying the y-axis accordingly. This is subsequently called within lapply
  #Save files internally, or return plots, depending on the returnplot argument
  #Internally, recode plotting according to the element specified to 'yaxis'.
  ggsummaryplot <- lapply(opt$GWASsumplots,ggSummaryplot,xlim=c(reg_range["start"],reg_range["stop"]),colourMapping=colourMapping,figdir=figdir,traits=traits,
                          returnplot=opt$GWASsumplots_onefile,facetTraits=TRUE,alignment=opt$genomeAlignment)
  
  #Optionally combine all summary plots into a single file; this will be in the order specified 
  if(opt$GWASsumplots_onefile){
  
    if(length(ggsummaryplot)>1){
      #Save the arranged plot using custom function wrapped around egg::ggarrange
      jointPlots <- egg_ggarr_wlegend(ggsummaryplot,ncol=1)
      
    } else {
      #If only one plot, use it 'as is'
      jointPlots <- ggsummaryplot
      
    }
    
    height=50*length(ggsummaryplot)
    ggsummaryfile <- ggsave(file.path(figdir,paste0(paste0(traits,collapse="_"),"_summary_plots.pdf")),
                            jointPlots,device="pdf",units="mm",width=175,height=height)
    
    #Save the file locations only. Cat this to log file after colocalisation steps
    ggsummaryfile <- basename(ggsummaryfile)
    
  } else {
    #If written as separate files, save the file locations only
    ggsummaryfile <- basename(unlist(ggsummaryplot))
    
  }
}

if(opt$runMode=="finemapOnly"){
  sink(file = logfile, append = T)
  cat("Skipping colocalisation analysis because the 'finemapOnly' setting is declared in the --runMode option.\n")
  sink()
  
} else if(length(traits)==1){
    sink(file = logfile, append = T)
    cat("Skipping colocalisation analysis because only one trait has been provided.\n")
    sink()
    
} else {
  
  #Subset to traits 1 and 2, if more have been supplied for prior steps.
  if(length(traits)>2){
    sink(file = logfile, append = T)
    cat("Colocalisation analysis can only be performed for pairs of traits. Proceeding with the first two traits only.\n")
    sink()
    
    traits<- traits[1:2]
    SusieFail<- SusieFail[1:2]
  }
  
  #Separate into distinct objects consistent with initial script config for downstream analysis.
  #Ensure only the first two datasets are passed onward
  sums1.region <- sums.region[[1]]
  sums2.region <- sums.region[[2]]
  
  susie1_rep <- susie_rep[[1]]
  susie2_rep <- susie_rep[[2]]
  

######
### Proceed with colocalisation step
######
sink(file = logfile, append = T)
cat("\n######\n### Colocalisation results\n######\n\n")
sink()

#Character vector to flag which coloc analyses have been performed
coloc_performed <- character(0)

#If either SuSiE call failed, a credible set has not been found for both traits, or if analysis is passed direct to coloc, run coloc.abf
if(any(SusieFail) || !all(susie1_rep$csFound,susie2_rep$csFound) || opt$runMode %in% c("doBoth","skipSusie")){  
  clc.abf<- coloc.abf(dataset1=sums1.region, dataset2=sums2.region)
  
  #Save the coloc abf results as a resource
  colocpath<- file.path(datadir,"colocalisation")
  if(!dir.exists(colocpath)){dir.create(colocpath)}
  saveRDS(clc.abf,file=file.path(colocpath,paste0("coloc_abf_",paste0(traits,collapse="_"),".Rds")))

  sink(file = logfile, append = T)
  cat("Colocalisation will now be performed without passing first to SuSiE [see coloc::coloc.abf].\n")
  cat("Thus, the single causal variant assumption has not been relaxed.\n")
  cat("coloc.abf was performed with the following priors:\n")
  print(clc.abf$priors)
  cat("coloc.abf results summary:\n")
  print(clc.abf$summary)
  cat("This summary is also returned in the file: results_summary_coloc_abf.csv\n")
  sink()
  
  #Save the results summary in a table which can be readily combined with other outputs
  Sum_abf<- t(enframe(c(traits,region=paste0("Chr", reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"]),clc.abf$priors,clc.abf$summary)))
  Sum_abf[1,1:length(traits)] <- paste0("TraitID_",1:length(traits))
  
  write.table(Sum_abf,file=file.path(tabdir,"results_summary_coloc_abf.csv"),sep = ",",row.names=FALSE,col.names = FALSE,quote = FALSE)
  
  #Save PP.H4.abf summaries, with additional details to file
  sets_outpath<- file.path(tabdir,"coloc.susie_snpwise_PP_H4_abf.csv")
  
  #Store in plotdata option for potential plotting
  plotdata.abf <- sums1.region %>%
    as.data.frame() %>%
    dplyr::select(snp,pos) %>%
    right_join(clc.abf$results,by="snp")
  
  write.table(plotdata.abf,file=sets_outpath,sep = ",",row.names=FALSE)
  
  sink(file = logfile, append = T)
  cat("\nSNPwise posterior probabilities of being a shared variant for",paste(traits,collapse = " & "),"under coloc.abf are tabulated in:\n", basename(sets_outpath),"\n")
  sink()
  
  #Flag which coloc analysis has been performed 
  coloc_performed <- c(coloc_performed, "coloc.abf")
}

#If both susie calls are successful and credible sets identified, run coloc.susie.
#Note that plots will overwrite any from Coloc.abf.
if(!any(SusieFail) && all(susie1_rep$csFound,susie2_rep$csFound) && opt$runMode %in% c("doBoth","trySusie")){
  clc<- coloc.susie(dataset1=susie[[1]], dataset2=susie[[2]]) ###Run coloc based on susie outputs
  
  #Save the coloc abf results as a resource
  colocpath<- file.path(datadir,"colocalisation")
  if(!dir.exists(colocpath)){dir.create(colocpath)}
  saveRDS(clc,file=file.path(colocpath,paste0("coloc_susie_",paste0(traits,collapse="_"),".Rds")))

  sink(file = logfile, append = T)
  cat("------------------------------\n")
  cat("coloc.susie was performed with the following priors:\n")
  print(clc$priors)
  invisible(print(clc$summary)) #Call summary invisibly first to avoid triggering bug where no output is printed
  cat("coloc.susie results summary:\n")
  print(clc$summary)
  cat("This summary is also returned in the file: results_summary_coloc_susie.csv.\n")
  sink()
  
  #Save the results summary in a table which can be readily combined with other outputs
  if(nrow(clc$summary)>1){
    Sum_clcsusie<- c(traits,region=paste0("Chr", reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"]),clc$priors) %>%
      t() %>%
      .[rep(1,nrow(clc$summary)),] %>%
      cbind(.,clc$summary)
  } else {
    Sum_clcsusie<- c(traits,region=paste0("Chr", reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"]),clc$priors,clc$summary) %>%
      t()
  }
  colnames(Sum_clcsusie)[1:length(traits)] <- paste0("TraitID_",1:length(traits))
  
  write.table(Sum_clcsusie,file=file.path(tabdir,"results_summary_coloc_susie.csv"),sep = ",",row.names=FALSE,col.names = TRUE,quote = FALSE)
  
  coloc_performed <- c(coloc_performed, "coloc.susie") #Flag which coloc analysis have been performed 
}


######
### Prepare to plot the results of colocalisation analysis, and write table if coloc.susie is applied
#####

#For plotting, generate labels for SNPs with the top 5% posterior probability of being a shared variant
label_limit <- ceiling(length(snplist)*0.05)

#However, limit the top number of snps to 10 at most 
if(label_limit>10){
  label_limit <- 10
}

toPlot<- list()

if("coloc.abf" %in% coloc_performed){
  
  #Colour likely snps under the assumption that h4 is true: " https://chr1swallace.github.io/coloc/articles/a03_enumeration.html
  toPlot[[1]] <- plotdata.abf %>%
    arrange(desc(SNP.PP.H4)) %>%
    mutate(cs_coloc=cumsum(SNP.PP.H4),                                             #Establish coloc.credible set
           thresh=if_else(row_number() <= label_limit, as.character(snp),""), #Label top snps
           cs_coloc=case_when(row_number() == 1 ~ "within set",               #Top snp is always within set
                              lag(cs_coloc) < 0.95 ~ "within set",             #lag checks previous record. If this value is <0.95 then snp is in set
                              TRUE ~ "outside set"),
           cs_coloc= factor(cs_coloc,levels=c("within set","outside set")))
}

if("coloc.susie" %in% coloc_performed){
  
  #More descriptive results tabulation
  clc$results <- sums1.region %>%
    as.data.frame() %>%
    dplyr::select(snp,pos) %>%
    full_join(snp_CS,by="snp") %>%
    full_join(clc$results,by="snp") %>%
    rename(cs_susie=cs)
  
  #Save PP.H4 summaries, with additional details, to file
  sets_outpath<- file.path(tabdir,"coloc.susie_snpwise_PP_H4_abf.csv")
  write.table(clc$results,file=sets_outpath,sep = ",",row.names=FALSE)
  
  sink(file = logfile, append = T)
  cat("\nSNPwise posterior probabilities of being a shared variant for",paste(traits,collapse = " & "),"under coloc.susie are tabulated in:\n", basename(sets_outpath),"\n")
  sink()
  
  #Prepare plotting for each 'row' of coloc.susie
  for(i in 1:nrow(clc$summary)){
    
    #Extract a given plotdata column
    plotdata <- clc$results[,c(1:3,i+3)]
    #clc_col_index <- which(grepl("SNP.PP.H4",colnames(plotdata)))
    
    #Assign labels to top X% of SNPs, arranged by PP in column
    plotdata<- plotdata %>%
      arrange(desc(.[[4]])) %>%
      mutate(cs_coloc=cumsum(.[[4]]),                                                #Establish coloc.credible set
             thresh=if_else(row_number() <= label_limit, as.character(snp),""), #Label top snps
             cs_coloc=case_when(row_number() == 1 ~ "within set",               #Top snp is always within set
                                lag(cs_coloc) < 0.95 ~ "within set",             #lag checks previous record. If this value is <0.95 then snp is in set
                                TRUE ~ "outside set"),
             cs_coloc= factor(cs_coloc,levels=c("within set","outside set")))
      
  toPlot[[length(toPlot)+1]] <- plotdata
  }
  
}
sink(file = logfile, append = T)
cat("------------------------------\n")
sink()

######
### Produce plots recurrently across toPlot list
#####
for(i in 1:length(toPlot)){
  
  #Extract plotting dataframe
  clc_col_index <- grep("SNP.PP.H4",colnames(toPlot[[i]]),value = TRUE)
  plotdata<- toPlot[[i]] %>%
    rename(SNP.PP=all_of(clc_col_index))
  
  #Set parameters for loop according to whether a coloc.abf or coloc.susie analysis is being plotted
  if(("coloc.susie" %in% coloc_performed && !"coloc.abf" %in% coloc_performed) ||
     ("coloc.susie" %in% coloc_performed && "coloc.abf" %in% coloc_performed && i!=1)){
    
    #Identify the current analysis, for later logic checks
    current <- "susie"
    
    # #Set colour mapping and legend
    colourMapping = "cs_susie"
    nameColourLegend<- "SuSiE fine-mapping\n(Trait: 95% credible set)"
    
    #Determine filename for loop, first identify which cs are compared, then name accordingly
    if("coloc.abf" %in% coloc_performed){ 
      ind <- i-1
    } else {
      ind <- i
    }
    cs_index<- clc$summary[ind,c("idx1","idx2")]
    cs_label <- paste(traits,cs_index,sep=":")
    cs_filenm <- paste(paste(traits,cs_index,sep="cs"),collapse="_")
    
    filename<- file.path(figdir,paste0("coloc.susie_result_all_snps_",cs_filenm,".pdf"))
    
  } else {
    #Identify the current analysis, for later logic checks
    current <- "abf"
    
    # # #Set colour mapping and legend
    colourMapping <- NULL
    nameColourLegend <- NULL
    
    #Determine filename for loop
    cs_filenm <- ".abf"
    filename<- file.path(figdir,"coloc.abf_result_all_snps.pdf")
    
  }
  
  #Set shape mapping and legend
  shapeMapping <- "cs_coloc"
  nameShapeLegend <- "Colocalisation\n(95% credible set\nassuming shared\nvariant)"
  
  #Build all snps plot, add labels for snps
  snp_PP <- ggSummaryplot(yaxis="SNP.PP",
                          xstring="pos",
                          xlim=c(reg_range['start'],reg_range['stop']),
                          dset=plotdata,
                          colourMapping=colourMapping,
                          shapeMapping=shapeMapping,
                          figdir=figdir,
                          traits=traits,
                          returnplot=TRUE,
                          facetTraits = FALSE,
                          nameColourLegend=nameColourLegend,
                          nameShapeLegend=nameShapeLegend,
                          alignment=opt$genomeAlignment) +
    geom_text_repel(aes(label=thresh), max.overlaps = 20, na.rm=TRUE, show.legend = FALSE)
  
  #Saveplot
  ggsave(filename,snp_PP,device="pdf",units="mm",width=150,height=175)
  
  
  #### Replot colocalised snps based on nearby genes
  min_bp<-min(plotdata$pos[plotdata$cs_coloc=="within set"])-gene_window #10KB
  max_bp<-max(plotdata$pos[plotdata$cs_coloc=="within set"])+gene_window #10KB
  chr<- reg_range["chr"]
  
  #Extract genes within the start or stop positions within 
  #Genes_subset<-Genes[Genes$start_position > min_bp & Genes$end_position < max_bp & Genes$chromosome_name == chr,] %>%
  Genes_subset <- Genes[Genes$chromosome_name == chr & (
    (Genes$start_window > min_bp & Genes$start_window < max_bp) |
      (Genes$end_window > min_bp & Genes$end_window < max_bp) |
      (Genes$start_window < min_bp & Genes$end_window > max_bp)
  ),]
  
  #If nearby snps are found, do further plotting, otherwise write message
  if(nrow(Genes_subset)>0){
    
    Genes_subset <- Genes_subset %>%
      arrange(start_position) %>%                      #Sort by start position
      mutate(midpoint=(start_position+end_position)/2, #Determine middle of gene position
             external_gene_name=factor(external_gene_name,levels = rev(external_gene_name[!duplicated(external_gene_name)]))) #Save as factor variable, to maintain sort order
    

    #Save details for nearby genes
    sets_outpath<- file.path(tabdir,paste0("nearby_genes_coloc",cs_filenm,".csv"))
    Genes_subset %>%
      dplyr::select(-c(start_window,end_window,midpoint)) %>%
      write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
    
    sink(file = logfile, append = T)
    
    if(current=="susie"){
      cat("\nGenes located within a 10Kb window around the top 10% of snps from current pair of SuSiE credible sets are tabulated in: ", basename(sets_outpath),"\n")
    } else {
      cat("\nGenes located within a 10Kb window around the top 10% of coloc.abf snps are tabulated in: ", basename(sets_outpath),"\n")
    }
    sink()
    
    if(!is.null(opt$restrict_nearby_gene_plotting_source)){ #If subsetting to named gene sources
      
      geneSources <-strsplit(opt$restrict_nearby_gene_plotting_source,split=",")[[1]] #String split on comma to identify sources
      sourceSubset<- which(Genes_subset$external_gene_source %in% geneSources)        #Find matching rows
      
      if(length(sourceSubset)>0){                                                     #If at least one gene remains, subset
        Genes_subset<- Genes_subset[sourceSubset,]
      } else {
        sink(file = logfile, append = T)
        cat("\nCould not subset nearby gene plotting by source since no genes remained after restricting to", paste0(geneSources,collapse=", "), "\n")
        sink()
      }
    }
    
    #Identify the x axis range based on max and minimum gene windows - plot only genes with a HGNC symbol
    #plot_rng <- c(min(Genes_subset$start_window[Genes_subset$external_gene_source=="HGNC Symbol"]),max(Genes_subset$end_window[Genes_subset$external_gene_source=="HGNC Symbol"]))
    plot_rng <- c(min(c(min_bp,Genes_subset$start_window)),max(c(max_bp,Genes_subset$end_window)))
    
    #Determine x-scale magnitude conversion
    xScale<-xScaler(plot_rng[2]-plot_rng[1])
      
    if(is.null(opt$gene_tracks) || (nrow(Genes_subset)<opt$gene_tracks && !is.null(opt$gene_tracks))){
      #Plot nearby genes using a unique plotting approach, scaling axes accordingly
      gene_near <- Genes_subset %>%
        ggplot(.,aes(x=midpoint, y=external_gene_name))+
        geom_errorbar(aes(xmin=start_position,xmax=end_position),width=0)+
        theme_bw()+
        theme(axis.text.y = element_text(face="italic"))
      
    } else {
    ## USE A REVISED PLOTTING APPROACH - permits multiple genes on one y-axis level, buffered by genomic position
    
    genespacing<- (plot_rng[2]-plot_rng[1])/5
      
    Genes_subset$track <- 1           #Assign all genes to track 1 initially
    for(t in 2:nrow(Genes_subset)){   #For each gene, tracks upwards to avoid overlap with those in current track
      prior <- Genes_subset[1:(t-1),]
      
      r=1                             #Start from track number 1, and while overlapping, increase tracks until adequate plotting space is found
      inTrack<- which(prior$track==r) #identify rows in current track
      while(length(inTrack)>0){ #While in an existing track
        if(Genes_subset$start_position[t]>(max(prior$end_position[inTrack])+genespacing)){ #If the start position is more than 100Kb apart from the previous gene in track, then assign gene to track
          Genes_subset$track[t] <- r
          break #break loop
          
        } else { #increase track number
          r <- r+1
          inTrack<- which(prior$track==r) #identify rows in current track
          if(length(inTrack)==0){ #If this is a new track, assign final track number and loop will break
            Genes_subset$track[t] <- r
          }
        }
      }
    } #End tracking loop
    
    #Convert to factor in order to display lower tracks higher
    tracklevels<- rev(sort(unique(Genes_subset$track)))
    Genes_subset$track <- factor(Genes_subset$track,levels=tracklevels) 
    
    #Plot nearby genes using a unique plotting approach, scaling axes accordingly
    gene_near <- Genes_subset %>%
      ggplot(.,aes(x=midpoint, y=track))+
      geom_text_repel(aes(label=external_gene_name),fontface="italic",direction="y",size=3)+
      theme_bw()+
      theme(axis.text.y = element_blank(),
            axis.ticks.y = element_blank())
    }
    
    #Add universal plot layers
    gene_near <- gene_near + 
      geom_errorbar(aes(xmin=start_position,xmax=end_position),width=0)+
      scale_x_continuous(limits = plot_rng,
                         breaks = scales::breaks_extended(n=4), 
                         labels=scales::label_number(scale = 1 / xScale$xscale,accuracy = 0.1))+ #Scale axis magnitude dynamically
      labs(x=paste0("GRCh",opt$genomeAlignment," genomic position (Chr", reg_range["chr"],":",plot_rng[1],"-",plot_rng[2],")",xScale$xscale_magnitude),
           y="Nearby genes")

    
    #Narrow the snp plot xlim to match gene_near
    suppressMessages({ #Suppress warning about 'double-setting' xlim
      snp_PP_range <- snp_PP +
        scale_x_continuous(limits = plot_rng,
                           breaks = scales::breaks_extended(n=4), 
                           labels=scales::label_number(scale = 1 / xScale$xscale,accuracy = 0.1)) #Scale axis magnitude dynamically
    })
    
    #If susie has been plotted, colouring is used to label Susie credible sets, adjust legend to include only snps in the new plot range
    if(current=="susie"){ 
      #To ensure consistent colouring when reassigning the colour factor, assign factor levels to specific colours
      levels<- levels(plotdata[[colourMapping]])
      col_levels <-ggpalette[1:length(levels)]
      names(col_levels)<- levels
      
      suppressMessages({ #Suppress warning about redoing existing legend
        snp_PP_range <- snp_PP_range +
          scale_colour_manual(na.value = "black", values=col_levels,
                              breaks = levels(droplevels(plotdata[which(plotdata$pos > plot_rng[1] & plotdata$pos < plot_rng[2]),colourMapping])))
      })
    }
    
    #Scale plot proportions according to number of genes plotted, but cap at 1, indicating equal proportions
    
    #To accommodate labelling when using track-based plotting, give extra buffer room per track
    if(is.null(opt$gene_tracks) || (nrow(Genes_subset)<opt$gene_tracks && !is.null(opt$gene_tracks)) ){
      propor <- 0.05*length(gene_near$data$external_gene_name)
    } else {
      propor <- 0.2*length(levels(gene_near$data$track))
    }
    if(propor>1){propor <- 1}
    
    g_arr <- egg_ggarr_wlegend(list(snp_PP_range,gene_near),position = "right",ncol=1,heights=c(1,propor))
    
    #If plotting the result of coloc.susie analysis, add extra info relevant to credible set assignments 
    if(current=="susie"){
      filename<- file.path(figdir,paste0("coloc_susie_likely_snps_with_genes",cs_filenm,".pdf"))
      
    } else {
      filename<- file.path(figdir,"coloc_abf_likely_snps_with_genes.pdf")
    }
    
    ggsave(filename,g_arr,device="pdf",units="mm",width=150,height=175)
    
  } else { #Conditional statement for when no nearby genes are found
    
    sink(file = logfile, append = T)
    
    if(("coloc.susie" %in% coloc_performed && !"coloc.abf" %in% coloc_performed) ||
       ("coloc.susie" %in% coloc_performed && "coloc.abf" %in% coloc_performed && i!=1)
    ){
      cat("\nNo genes were identified within a 10Kb window around snps from the current credible sets comparison:",gsub("_"," & ",cs_filenm),".\n")
    } else {
      cat("\nNo genes were identified within a 10Kb window around the top 10% of coloc.abf snps.\n")
    }
    sink()
    
  }
  
} 
} #Bracket indicating the end of the else condition performed when opt$runMode!="finemapOnly"

sink(file = logfile, append = T)
cat("------------------------------\n")
sink()

#Write to log which GWAS summary plots have been written
sink(file = logfile, append = T)
cat("Selected graphical comparison between summary statistics has been written to the file(s):\n",
    paste0(ggsummaryfile,sep="\n"),"\n")
sink()
