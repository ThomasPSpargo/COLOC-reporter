#####
# Author: Thomas Spargo (thomas.spargo@kcl.ac.uk)
# Obtained from GitHub repository: https://github.com/ThomasPSpargo/COLOC-reporter
#
# This script performs colocalisation analysis between two traits at a specified genomic region. 
# Preprocessing and finemapping are handled per-trait and colocalisation analysis is performed with the COLOC software, either using coloc.abf or coloc.susie.
#####
suppressPackageStartupMessages(library(optparse))

option_list = list(
  
  #General options
  make_option("--LAVAfile", action="store", default=NA, type='character',
              help='Path to bivariate genetic correlation summary generated by LAVA. The script extract the locus with the smallest p-value by default. To analyse other genomic regions use the --set_locus option. If --set_locus specifies a comma separated genomic region directly list of the format "chromosome,start_position,end_position" (e.g. 17,43460501,44865832) then no --LAVAfile is required.'),
  make_option("--plink", action="store", default='plink', type='character',
              help="Path to PLINK executable (syntax written for PLINK 1.9). By default, has the value 'plink'"),
  make_option("--traits", action="store", default=NULL, type='character',
              help="Comma separated list of IDs for traits to analyse (e.g. 'P1,P2'), as relevant to the summary statistics provided in --sumstat1 and --sumstat2 options."),
  make_option("--traitLabel1", action="store", default=NULL, type='character',
              help="Character string giving a 'long' name for the first trait. To be used in plotting. If NULL, will default to the trait ID."),
  make_option("--traitLabel2", action="store", default=NULL, type='character',
              help="Character string giving a 'long' name for the second trait. To be used in plotting.If NULL, will default to the trait ID. This option is not affected by --match_sum1_opts."),
  make_option("--set_locus", action="store", default=NA, type='character',
              help='Specify target locus to test, either as a number referring to a locus from --LAVAfile, or as a comma separated list of the format "chromosome,start_position,end_position" (e.g. 17,43460501,44865832).'),
  make_option("--LDreference", action="store", default=NA, type='character',
              help="Path to, and prefix for, per-chromosome PLINK binary files used to compute LD matrix for SNPs in region. This input is used by SuSiE. Expected format of <prefix>i.bim, where i is the chromosome number"),
  make_option("--GWASconfig", action="store", default=NULL, type='character',
              help="Path to file specifying configuration of GWAS sumstats. Configuration will be determined by identifying rows whose IDs match the --traits option."),
  make_option("--match_sum1_opts", action="store", default=FALSE, type='logical',
              help="Specify whether duplicated options in summary stats 2 match those of sumstats 1. If TRUE they will be set automatically, unless option is specifically given [logical, defaults to FALSE]"),
  make_option("--runMode", action="store", default="trySusie", type='character',
              help="Character string, any of 'trySusie', 'skipSusie', 'doBoth'.\nIf 'doBoth', both coloc.abf and coloc.susie will attempt to run.\nIf 'trySusie' coloc.susie will be used if SuSiE finemapping identifies at least 1 credible set in each trait and coloc.abf is returned if the SuSiE finemapping step fails.\nIf 'skipSusie', only coloc.abf will be applied, and processes necessary for coloc.susie are skipped (e.g. no need to call to plink and generate LD matrix); the LD reference will however still still used for SNP alignment."),
  make_option("--force_matrix", action="store", default=FALSE, type='logical',
              help="If TRUE, the LD matrix will always be recomputed using PLINK. If FALSE, the default, the LD matrix will only be computed if the expected ld_matrix.snplist and ld_matrix.ld files are absent from the <output>/LDmatrix directory."),
  make_option("--out", action="store", default="./COLOC-reporter", type='character',
              help="Path and prefix for directory in which to return all outputs. Defaults to ./COLOC-reporter. When running multiple analyses, unique output directories are essential for tidy file organisation."),
  make_option("--GWASsumplots", action="store", default="p", type='character',
              help="Character string or vector with any combination of c('PIP','p','z','beta'); defaults to 'p'. Generate ggplots comparing summary statistic results on named statistic for both traits. See also the associated --GWASsumplots_onefile --GWASsumplots_incfinemapping options. PIP refers to posterior inclusion probabilities for snps as indicated from SuSiE"),
  make_option("--GWASsumplots_onefile", action="store", default=FALSE, type='logical',
              help="Logical, defaults to FALSE. When --GWASsumplots has more then one element, indicate TRUE to return all comparisons bound into a single figure; plots will be stacked vertically, in the order of the --GWASsumplots vector."),
  make_option("--GWASsumplots_incfinemapping", action="store", default=TRUE, type='logical',
              help="Logical, defaults to TRUE. If TRUE, and if any credible sets are identified across the two traits, plots returned by --GWASsumplots will include colouring indicating which snps belong to which credible sets."),
  make_option("--genomeAlignment", action="store", default=37, type='numeric',
              help="Indicate the reference genome to which summary statistics and LD reference are aligned. Defaults to 37."),
  make_option("--gene_tracks", action="store", default=NULL, type='numeric',
              help="Numeric. Specify the threshold at which plotting of nearby genes changes from one gene per row to plotting multiple genes across individual rows, labelling genes with geom_text_repel. Defaults to NULL, where per-row plotting has no upper limit. Specify 1 to always plot multiple genes per row, provided their genomic positions do not overlap [work in progress]."),
  make_option("--restrict_nearby_gene_plotting_source", action="store", default=NULL, type='character',
              help="Comma delimited character string indicating sources from which nearby genes included in plots are retrieved. Check output tables 'external_gene_source' column for options. Included as an option to reduce overplotting of obscure gene symbols. If NULL, all sources will plot"),
  make_option("--helperFunsDir", action="store", default=NULL, type='character',
              help="Filepath to directory containing helper functions used within the script"),
  
  
  
  #Options For summary statistics 1 (will also be applied to summary statistics 2 if --match_sum1_cols TRUE and if options are not otherwise specified)
  make_option("--sumstat1", action="store", default=NA, type='character',
              help="Path to summary statistics for primary file"),
  make_option("--type1", action="store", default=NA, type='character',
              help="Indicate whether phenotype is 'quant' or 'cc' (case control)"),
  make_option("--prop1", action="store", default=0.5, type='numeric',
              help="For cc trait, Indicate proportion of data is from cases"),
  make_option("--pcolumn1", action="store", default=NA, type='character',
              help="Column name for p-values"),
  make_option("--statcol1", action="store", default=NA, type='character',
              help="Column name for test statistic, expects column referring to the beta coefficients, if odds ratios given, column must be called 'OR' "),
  make_option("--Ncol1", action="store", default=NA, type='character',
              help="Column name for each snp sample size"),
  make_option("--chromosome1", action="store", default=NA, type='character',
              help="Column name for chromosome"),
  make_option("--positions1", action="store", default=NA, type='character',
              help="Column name for genomic position"),
  make_option("--error1", action="store", default=NA, type='character',
              help="Column name for test statistic error"),
  make_option("--snpcol1", action="store", default=NA, type='character',
              help="Column name for SNP ids"),
  make_option("--freq1", action="store", default="REF.FREQ", type='character',
              help="Column name with allele frequency information"),
  
  #Duplicated options for summary statistics 2
  make_option("--sumstat2", action="store", default=NA, type='character',
              help="Path to summary statistics for primary file"),
  make_option("--type2", action="store", default=NA, type='character',
              help="Indicate whether phenotype is 'quant' or 'cc' (case control)"),
  make_option("--prop2", action="store", default=0.5, type='numeric',
              help="For cc trait, Indicate proportion of data is from cases"),
  make_option("--pcolumn2", action="store", default=NA, type='character',
              help="Column name for p-values"),
  make_option("--statcol2", action="store", default=NA, type='character',
              help="Column name for test statistic, expects column referring to the beta coefficients, if odds ratios given, column must be called 'OR' "),
  make_option("--Ncol2", action="store", default=NA, type='character',
              help="Column name for each snp sample size"),
  make_option("--chromosome2", action="store", default=NA, type='character',
              help="Column name for chromosome"),
  make_option("--positions2", action="store", default=NA, type='character',
              help="Column name for genomic position"),
  make_option("--error2", action="store", default=NA, type='character',
              help="Column name for test statistic error"),
  make_option("--snpcol2", action="store", default=NA, type='character',
              help="Column name for SNP ids"),
  make_option("--freq2", action="store", default="REF.FREQ", type='character',
              help="Column name with allele frequency information")
)

opt = parse_args(OptionParser(option_list=option_list))

#######
### Begin script
#######
#options(echo=FALSE)

suppressPackageStartupMessages({
  library(tidyverse)
  library(data.table) #To read in the datasets
  library(R.utils)    #Required reading gz files directly with fread
  library(coloc)
  library(susieR)
  library(biomaRt)    #For ensembl library
  library(ggrepel)
  library(egg)     #arranging summary plot
})


test <- FALSE # test <- TRUE
if(test==TRUE){
  #####
  setwd("/Users/tom/OneDrive - King's College London/PhD/PhD project/COLOC/git.local.COLOC-reporter/testing")
  opt <- list()
  
  #Not needed
  #opt$LAVAfile <- "/scratch/users/k1802739/LAVA/results/PD.SZ.bivar"
  
  # # #TESTING V1
  opt$set_locus <- "17,43460501,44865832"
  opt$sumstat1 <- "./PD.sumstats.gz"
  opt$sumstat2 <- "./SZ.sumstats.gz"
  opt$freq2 <- "REF.FREQ"
  opt$out <- "./test_v2_PD.SZ.chr17"
  opt$traits <- c("PD,SZ")
  opt$traitLabel1 <- "Parkinson's Disease"
  opt$traitLabel2 <- "Schizophrenia"
  
  #TESTING V2
  # opt$set_locus <- "9,27366480,28067454"
  # opt$sumstat1 <- "./ALS.sumstats.txt"
  # opt$sumstat2 <- "./SZ.sumstats.txt"
  # opt$freq2 <- "REF.FREQ"
  # opt$out <- "./testing_ALS.SZ.chr9"
  #opt$traits <- c("ALS,SZ")
  # opt$traitLabel1 <- "Amyotrophic lateral sclerosis"
  # opt$traitLabel2 <- "Schizophrenia"
  
  # # #TESTING V3
  # opt$set_locus <- "16,86058598,86748867"
  # opt$sumstat1 <- "./ALS.sumstats.txt"
  # opt$sumstat2 <- "./PD.sumstats.txt"
  # opt$freq2 <- "FREQ"
  # opt$out <- "./testing_ALS.PD.chr16"
  #opt$traits <- c("ALS,PD")
  # opt$traitLabel1 <- "Amyotrophic lateral sclerosis"
  # opt$traitLabel2 <- "Parkinson's Disease"
  
  opt$LDreference <- './EUR_phase3_chr'
  opt$runMode <- 'doBoth'
  opt$force_matrix <- FALSE
  opt$type1 <- "cc"
  opt$prop1 <- 0.5
  opt$pcolumn1 <- "P"
  opt$statcol1 <- "BETA"
  opt$Ncol1 <- "N"
  opt$chromosome1 <- "CHR"
  opt$positions1 <- "BP"
  opt$error1 <- "SE"
  opt$snpcol1 <- "SNP"
  opt$freq1 <- "FREQ"
  opt$match_sum1_opts <- TRUE
  opt$gene_tracks <- 40
  opt$restrict_nearby_gene_plotting_source <- "HGNC Symbol"
  opt$helperFunsDir <- "/Users/tom/OneDrive - King's College London/PhD/PhD project/COLOC/git.local.COLOC-reporter/scripts/helper_functions"
  
  opt$genomeAlignment <- 37
  opt$GWASsumplots <- c("PIP","p","beta")
  opt$GWASsumplots_onefile <- FALSE
  opt$GWASsumplots_incfinemapping <- TRUE
  
  
  #Assign default options for testing, except opt$freq2, which has unique name across sumstats
  opt$type2 <- opt$pcolumn2 <- opt$statcol2 <- opt$Ncol2 <- opt$chromosome2 <- opt$positions2 <- opt$error2 <- opt$snpcol2 <- NA
  opt$prop2 <- 0.5
}

#Extract names of traits compared, first dropping file path, and then any prefixes indicated by a preceding underscore
traits <- strsplit(opt$traits,",")[[1]][1:2]

if(!is.null(opt$GWASconfig)){
  
  #Read in the configuration options
  GWASconfig<- fread(opt$GWASconfig)
  
  #Identify the rows which correspond to trait ID1 and ID2
  Config.index <- c(which(GWASconfig$ID %in% traits[1]),
                    which(GWASconfig$ID %in% traits[2])
                    )
  
  opt$type1 <- GWASconfig$type[Config.index[1]]
  opt$prop1 <- GWASconfig$prop[Config.index[1]]
  opt$pcolumn1 <- GWASconfig$pcolumn[Config.index[1]]
  opt$statcol1 <- GWASconfig$statcol[Config.index[1]]
  opt$Ncol1 <- GWASconfig$Ncol[Config.index[1]]
  opt$chromosome1 <- GWASconfig$chromosome[Config.index[1]]
  opt$positions1 <- GWASconfig$positions[Config.index[1]]
  opt$error1 <- GWASconfig$error[Config.index[1]]
  opt$snpcol1 <- GWASconfig$snpcol[Config.index[1]]
  opt$freq1 <- GWASconfig$freq[Config.index[1]]
  opt$traitLabel1 <- GWASconfig$traitLabel[Config.index[1]]
  opt$sumstat1 <- GWASconfig$FILEPATH[Config.index[1]]
  
  opt$type2 <- GWASconfig$type[Config.index[2]]
  opt$prop2 <- GWASconfig$prop[Config.index[2]]
  opt$pcolumn2 <- GWASconfig$pcolumn[Config.index[2]]
  opt$statcol2 <- GWASconfig$statcol[Config.index[2]]
  opt$Ncol2 <- GWASconfig$Ncol[Config.index[2]]
  opt$chromosome2 <- GWASconfig$chromosome[Config.index[2]]
  opt$positions2 <- GWASconfig$positions[Config.index[2]]
  opt$error2 <- GWASconfig$error[Config.index[2]]
  opt$snpcol2 <- GWASconfig$snpcol[Config.index[2]]
  opt$freq2 <- GWASconfig$freq[Config.index[2]]
  opt$traitLabel2 <- GWASconfig$traitLabel[Config.index[2]]
  opt$sumstat2 <- GWASconfig$FILEPATH[Config.index[2]]
  
  Config_msg <- paste0("Summary statistic configuration options set according to the specification of --GWASconfig for trait IDs 1: ", traits[1], " and 2: ",traits[2],".\n")
} else {
  Config_msg <- ""
}

#If sumstat 2 options should match sumstat 1 options (indicated by --match_sum1_cols TRUE) match options which are not otherwise explicitly named
if(isTRUE(opt$match_sum1_opts) && is.null(opt$GWASconfig)){
  if(is.na(opt$pcolumn2)){opt$pcolumn2 <- opt$pcolumn1}
  if(is.na(opt$statcol2)){opt$statcol2 <- opt$statcol1}
  if(is.na(opt$Ncol2)){opt$Ncol2 <- opt$Ncol1}
  if(is.na(opt$chromosome2)){opt$chromosome2 <- opt$chromosome1}
  if(is.na(opt$positions2)){opt$positions2 <- opt$positions1}
  if(is.na(opt$error2)){opt$error2 <- opt$error1}
  if(is.na(opt$snpcol2)){opt$snpcol2 <- opt$snpcol1}
  if(is.na(opt$freq2)){opt$freq2 <- opt$freq1}
  
  if(is.na(opt$type2)){opt$type2 <- opt$type1}
  if(opt$prop2==0.5){opt$prop2 <- opt$prop1}
}

#Assign names for use as labelling with the traits
names(traits) <- c(opt$traitLabel1, opt$traitLabel2) 


opt$out <- paste0(opt$out,"_coloc")
if(!dir.exists(opt$out)){dir.create(opt$out,recursive = TRUE)}

#Set up directories in which to return tables and figures
figdir <- file.path(opt$out,"plots")
if(!dir.exists(figdir)){dir.create(figdir)}
tabdir <- file.path(opt$out,"tables")
if(!dir.exists(tabdir)){dir.create(tabdir)}

logfile <- file.path(opt$out,'colocalisation.log')

#Setup a colour palette to be used across ggplots (colours taken from plot SuSiE)
ggpalette = c("dodgerblue2", "green4", "#6A3D9A", "#FF7F00", 
              "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", 
              "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", 
              "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", 
              "yellow3", "darkorange4", "brown")

sink(file = logfile, append = F)
cat(
  '#################################################################
# colocaliseRegion.R
# Perform colocalisation analysis between GWAS summary statistics in a predetermined genomic region.
# Colocalisation leverages the COLOC and SuSiE software packages.
# Genetic regions must either identified manually or can be selected based on output from LAVA software.
# Documentation for options for running the script can be called with: Rscript ./colocaliseRegion.R --help
# 
# This script was written by Thomas Spargo (thomas.spargo@kcl.ac.uk), please get in touch with any queries.
#
#################################################################
Analysis started at',as.character(Sys.time()),'\n',Config_msg,'Options are:\n')
print(opt)

cat("\n######\n### Setup \n######\n\n")

cat("All outputs will be returned in the directory: ", opt$out,"\n")
cat("All figures are returned in the subdirectory: ",basename(figdir),"\n")
cat("and tabular summaries in the subdirectory: ",basename(tabdir),"\n\n")

sink()

#Read-in custom helper functions stored in directory specified by opt$helperFunsDir
list.files(opt$helperFunsDir,full.names = TRUE,pattern=".R") %>%
  lapply(.,source) %>%
  invisible(.)

if(length(opt$GWASsumplots)>0){
  #Parse the comma delimited list
  opt$GWASsumplots <- strsplit(opt$GWASsumplots,",")[[1]]
  
  #Return warning if any of the gwas summary plot options are not recognised, then drop the unrecognised elements
  checksumplots<- tolower(opt$GWASsumplots) %in% c('pip','p','z','beta')
  if(any(!checksumplots)){
    sink(file = logfile, append = T)
    cat("WARNING: The --GWASsumplots option contained unrecognised strings which have been dropped. Please indicate any combination of 'pip', 'p', 'z', 'beta', case-insensitive)")
    sink()
    
    opt$GWASsumplots <- opt$GWASsumplots[-which(checksumplots)] #Drop the unrecognised strings
  }
}
       
       
  

########
##### Import first dataset
########
#Import first dataset
sums1 <- tibble(fread(opt$sumstat1))

#Check for column name options match the dataset, warn if not
colcheck <-  which(!(
  c(opt$pcolumn1,opt$statcol1,opt$Ncol1,opt$chromosome1,opt$positions1,opt$error1,opt$snpcol1,opt$freq1)
  %in% colnames(sums1)
))
if(length(colcheck)>0){
  warning("The column names expected for the 1st set of summary statistics based on options set were not all detected when reading in the file. Please check the option(s) specified.")
}

#Unless specified to be an odds ratio, rename as beta
if(opt$statcol1=="OR"){
  sums1$beta <- log(sums1$OR)
  sums1$OR <- NULL
} else {
  colnames(sums1)[colnames(sums1)==opt$statcol1] <- "beta"
}

#Standardise other column names
names(sums1)[names(sums1)==opt$pcolumn1] <- "pvalues"
names(sums1)[names(sums1)==opt$chromosome1] <- "chr"
names(sums1)[names(sums1)==opt$positions1] <- "pos"
names(sums1)[names(sums1)==opt$error1] <- "SE"
names(sums1)[names(sums1)==opt$snpcol1] <- "snp"
names(sums1)[names(sums1)==opt$freq1] <- "MAF"


########
##### Import second dataset
########
#Parameters for the second dataset Copy from 1

#...
#Import data
sums2 <- tibble(fread(opt$sumstat2))

#Check for column name options match the dataset
colcheck <-  which(!(
  c(opt$pcolumn2,opt$statcol2,opt$Ncol2,opt$chromosome2,opt$positions2,opt$error2,opt$snpcol2,opt$freq2)
  %in% colnames(sums2)
))
if(length(colcheck)>0){
  warning("The column names expected for the 1st set of summary statistics based on options set were not all detected when reading in the file. Please check the option(s) specified.\n
          Note that these names may have been automatically assigned based on values for summary statistics 1 if --match_sum1_opts is set as TRUE")
}

if(opt$statcol2=="OR"){
  sums2$beta <- log(sums2$OR)
  sums2$OR <- NULL
} else {
  colnames(sums2)[colnames(sums2)==opt$statcol2] <- "beta"
}


#Standardise the names based on input options
names(sums2)[names(sums2)==opt$pcolumn2] <- "pvalues"
names(sums2)[names(sums2)==opt$chromosome2] <- "chr"
names(sums2)[names(sums2)==opt$positions2] <- "pos"
names(sums2)[names(sums2)==opt$error2] <- "SE"
names(sums2)[names(sums2)==opt$snpcol2] <- "snp"
names(sums2)[names(sums2)==opt$freq2] <- "MAF"



########
#### Filter dataset into interest region
########
if(!is.na(opt$set_locus)){
  
  opt$set_locus <- as.numeric(strsplit(opt$set_locus,",")[[1]])
  
  if(length(opt$set_locus)==3){
    #Set genomic positions manually
    reg_range <-c(chr=opt$set_locus[1],
                   start=opt$set_locus[2],
                   stop=opt$set_locus[3])
    
  } else if(length(opt$set_locus)!=1) {
    stop('The option --set_locus is defined but cannot be identified as specifying a genomic region manually (in the comma separated format "chromosome,start_position,end_position") or as single numeric referring to local genetic correlation locus from LAVA')
  } else {
    
    if(is.na(opt$LAVAfile)){
      stop('please set the option --LAVAfile when passing a single numeric in the --set_locus option; this numeric refers to the genomic region flagged by the locus number from LAVA.\n\nNote that --set_locus also accepts a manually defined genomic region (in the comma separated format "chromosome,start_position,end_position"), and the --LAVAfile option is ignored in this circumstance')
    }
    
    #Read the lava input, and extract the locus named
    LAVAfile <- tibble(fread(opt$LAVAfile))
    LAVAregion <- which(LAVAfile$locus==opt$set_locus)
    
    reg_range <-c( chr=LAVAfile$chr[LAVAregion],
                   start=LAVAfile$start[LAVAregion],
                   stop=LAVAfile$stop[LAVAregion])
  }
} else {
  #Read the lava input, and extract the locus with the smallest p-value
  LAVAfile <- tibble(fread(opt$LAVAfile))
  LAVAregion <- which(LAVAfile$p==min(LAVAfile$p))
  
  reg_range <-c( chr=LAVAfile$chr[LAVAregion],
                 start=LAVAfile$start[LAVAregion],
                 stop=LAVAfile$stop[LAVAregion])
}

target_region <- paste0("chr",reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"])

sink(file = logfile, append = T)
cat(paste0("Colocalisation analysis will be performed for the region: ", target_region," \n"))
sink()


######
# Harmonise summary statistics
######

# Read in reference SNP data to match alleles 
bim<-fread(paste0(opt$LDreference,reg_range["chr"],'.bim'))

#Drop sumstats 1 to snps in the chromosome:position range and present in the LD reference data
#Mutate to calculate the variance of the beta from standard error and N
sums1.region <- sums1 %>%
  filter(chr==reg_range["chr"],
         pos>=reg_range["start"],
         pos<=reg_range["stop"],
         snp %in% bim[["V2"]]
  ) %>%
  arrange(match(snp, bim[["V2"]]))

sink(file = logfile, append = T)
cat("Number of SNPs from sumstat 1 in tested region and LD reference:", nrow(sums1.region),"\n")
sink()

# #Repeat filtering for sumstats 2
sums2.region <- sums2 %>%
  filter(chr==reg_range["chr"],
         pos>=reg_range["start"],
         pos<=reg_range["stop"],
         snp %in% bim[["V2"]]
  ) %>%
  arrange(match(snp, bim[["V2"]]))
  

sink(file = logfile, append = T)
cat("Number of SNPs from sumstat 2 in tested region and LD reference:", nrow(sums2.region),"\n")
sink()

#Intersect the two snp lists
snplist <- intersect(sums1.region$snp, sums2.region$snp)

sink(file = logfile, append = T)
#Print some information to console
cat(paste0("N SNPs overlapping for both traits: ", length(snplist),"\n"))
sink()

#Intersect the overlapping SNPSs, and compute varbeta and position evidence
sums1.region <- sums1.region %>%
  filter(snp %in% snplist) %>%
  mutate(varbeta = SE^2,
         position = row_number())

sums2.region <- sums2.region %>%
  filter(snp %in% snplist) %>%
  mutate(varbeta = SE^2,
         position = row_number())






# Flip sumstat direction to match alleles across gwas and reference,
# also reverse allele frequency to refer to new effect allele
alignSS <- function(ss,bim){
  ss_bim_match<-merge(ss, bim, by.x=c('snp','A1','A2'), by.y=c('V2','V5','V6'))
  ss_bim_swap<-merge(ss, bim, by.x=c('snp','A1','A2'), by.y=c('V2','V6','V5'))
  
  ss<-ss[ss$snp %in% ss_bim_match$snp | ss$snp %in% ss_bim_swap$snp,] 
  ss$beta[ss$snp %in% ss_bim_swap$snp] <- -ss$beta[ss$snp %in% ss_bim_swap$snp]
  
  ss$MAF[ss$snp %in% ss_bim_swap$snp] <- 1-ss$MAF[ss$snp %in% ss_bim_swap$snp]
  
  return(ss)
}
sums1.region <- alignSS(sums1.region,bim)
sums2.region <- alignSS(sums2.region,bim)

#Return warning if the SNP position alignment seems incorrect
if(!identical(paste0(sums1.region$snp,"_",sums1.region$pos),
             paste0(sums2.region$snp,"_",sums2.region$pos))){
  sink(file = logfile, append = T)
  cat("WARNING: SNP names and genomic positions do not match between datasets. Please check that these have been aligned correctly.")
  sink()
}


######
# Generate LD matrix (for SuSiE)
######


if(opt$runMode %in% c("trySusie", "doBoth")){
  #Extract snps and write list to file in subdirectory of results directory
  
  #Check for the expected LD matrix output; if files are absent or if --force_matrix is set, generate using PLINK
  expect <- c(".snplist",".ld")
  expect <- file.path(opt$out,'LDmatrix',paste0('ld_matrix',expect))
  
  if(any(!file.exists(expect)) | opt$force_matrix){
    
    sink(file = logfile, append = T)
    cat("Computing LD matrix...")
    sink()
    
    ld_dir<- dirname(expect[1])
    
    if(!dir.exists(ld_dir)){dir.create(ld_dir,recursive = TRUE)}
    write(snplist, file=file.path(ld_dir,"snplist.txt"))
    
    #Identify LD matrixsnps from snplist present in reference
    #Syntax based on plink v 1.9
    system(paste0(opt$plink,' --bfile ', opt$LDreference,reg_range["chr"],
                  ' --extract ',ld_dir,'/snplist.txt',
                  ' --r square',
                  ' --write-snplist',
                  ' --keep-allele-order',
                  ' --out ',file.path(ld_dir,'ld_matrix')))
    
    sink(file = logfile, append = T)
    cat("Done\n")
    sink()
    
  } else {
    sink(file = logfile, append = T)
    cat("Existing LD matrix found, skipping call to PLINK\n")
    sink()
  }
  
  #Read in the ld matrix and snp names as returned by plink 
  ld <- as.matrix(fread(expect[2]))
  ld_names<- scan(expect[1],what=character())
  dimnames(ld)<-list(ld_names, ld_names) #assign dimnames to LD object
  
  #As a sanity check, redo alignment based on plink output order to ensure snps are correctly arranged in base pair order, and assign 'positions' for coloc
  sums1.region <- sums1.region %>%
    filter(snp %in% ld_names) %>%
    arrange(match(snp, ld_names)) %>%
    mutate(position = row_number())
  
  sums2.region <- sums2.region %>%
    filter(snp %in% ld_names) %>%
    arrange(match(snp, ld_names)) %>%
    mutate(position = row_number())
} 


######
# If doing summary plotting, extract a minimal combination of statistics from the harmonised datasets
# this will be used in plotting after attempting finemapping step
######
if(length(opt$GWASsumplots)>0){
  p_z_plotcols <-  c("snp","pos","beta","SE","pvalues")
  minimal_P1P2_df<- cbind(sums1.region[,p_z_plotcols],trait=unname(traits)[1]) %>%
    full_join(cbind(sums2.region[,p_z_plotcols],trait=unname(traits)[2]),by=c(p_z_plotcols,"trait"))
}


######
### Prepare for colocalisation analysis; convert data.frame to list and add expected list elements
######

##Expected elements:
#LD matrix (if passing via SuSiE)
#type = "cc" or "quant" depending on trait type
#s = case control proportion if "cc"
sums1.region <- as.list(sums1.region)
sums1.region$type <- opt$type1
if(opt$type1=="cc"){sums1.region$s <- opt$prop1}
if(opt$runMode %in% c("trySusie", "doBoth")){sums1.region$LD <- ld}

sums2.region <- as.list(sums2.region)
sums2.region$type <- opt$type2
if(opt$type2=="cc"){sums2.region$s <- opt$prop2}
if(opt$runMode %in% c("trySusie", "doBoth")){sums2.region$LD <- ld}



#Import gene information for region
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl", GRCh=opt$genomeAlignment)
Genes<-getBM(attributes=c('external_gene_name','chromosome_name','start_position','end_position','external_gene_source','strand'), mart = ensembl)

# Use 10kb window to define gene window
gene_window<-10000
Genes$start_window<-Genes$start_position-gene_window
Genes$end_window<-Genes$end_position+gene_window


# Do main Susie steps
if(opt$runMode %in% c("trySusie", "doBoth")){
  
  ######
  ### Define function to summarise susie results for both datasets
  ######
  susie_report <- function(susie.fit,basedata,trait){
    #Drop the list elements of basedata which cannot be converted to a dataframe, and then convert
    basedata$s <- basedata$type <- basedata$LD <- NULL
    basedata <- as.data.frame(basedata)
    
    sum_susie <- summary(susie.fit)
    csFound<- !is.null(sum_susie$cs) #Logical statement to pass through indicating TRUE if a CS has been identified
    
    ##### Generate summary table for PIP of SNPs
    sets<- sum_susie$vars #[sum_susie$vars$cs!=-1,] #Extract all snps
    sets<- cbind(sets,basedata[sets$variable,c("snp","chr","pos","pvalues","beta","SE")]) #Add relevant columns from GWAS sumstats
    
    #Save PIP summaries to file
    sets_outpath<- file.path(tabdir,paste0("susie_snp_summary_",trait,".csv"))
    write.table(sets,file=sets_outpath,sep = ",",row.names=FALSE)
    tab_out<- paste0("PIP summaries for SNPs for ",trait," are tabulated in:\n", basename(sets_outpath),"\n") #Info string
    
    ### Plot the pip summaries alongside snp p-values
    
    #Mutate data for plotting
    sets <- sets %>%
      mutate(cs = if_else(cs==-1,NA_real_,cs),
             cs = as.factor(cs),
             thresh = if_else(!is.na(cs),as.character(snp),""))
    
    if(csFound){ #if CS are found
      colourMapping <- "cs" #Dynamically set colour attribute 
      
      #Replicate Susie plot legend labelling
      CSlen<- sapply(susie.fit$sets$cs,length)
      CSmin<- susie.fit$sets$purity$min.abs.corr
      levels(sets$cs) <- paste0(names(susie.fit$sets$cs),": C=",CSlen,"/R=",round(CSmin,3))
      
    } else {
      colourMapping <- NULL
    }
    
    #Use trait name as plot title if possible
    if(!is.null(names(trait))){
      title <- names(trait)
    } else {
      title <- trait
    }
    
    #Supply string-based aesthetic elements via list
    aesthetics<- list(colour=colourMapping) %>%
      lapply(., function(x) if (!is.null(x)) sym(x))
    
    pips<- ggplot(sets,aes(x=pos,y=variable_prob,!!!aesthetics))+
      geom_point() +
      theme_bw()+
      theme(plot.title = element_text(hjust=0.5))+
      labs(y="PIP",x=paste0("GRCh",opt$genomeAlignment," genomic position (",target_region,")"),title=title)
    
    #Add colours to plots if a credible set has been identified
    if(!is.null(colourMapping)){
      pips <- pips +
        scale_colour_manual(na.value = "black", values=ggpalette,breaks=levels(sets$cs))+
        guides(color=guide_legend(title="Credible set"))
    }
    
    ggsave(file.path(figdir,paste0("susie_PIP_",trait,".pdf")),pips,device="pdf",units="mm",width=150,height=150)
    
    if(csFound){
      ##### Create summary file    
      finemap_summary <- data.frame(CS_span = NA,
                                    beta_maxSNP = basedata$snp[which(basedata$beta==max(basedata$beta))],
                                    p_minSNP = basedata$snp[which(basedata$pvalues==min(basedata$pvalues))],
                                    TopPIPsnp = NA,
                                    sum_susie$cs,
                                    NSNP=NA,
                                    TopPIP=NA,
                                    Genes_near_span=NA)
      
      for(j in 1:nrow(sum_susie$cs)){
        snp_index<-as.numeric(unlist(strsplit(finemap_summary$variable[j], ',')))
        
        finemap_summary$NSNP[j] <- length(snp_index)
        finemap_summary$TopPIP[j]<-max(susie.fit$pip[snp_index])
        finemap_summary$TopPIPsnp[j]<- paste(names(susie.fit$pip)[susie.fit$pip==finemap_summary$TopPIP[j]], collapse=', ')
        
        ss_subset<-basedata[(basedata$snp %in% names(susie.fit$pip)[snp_index]),]
        min_bp<-min(ss_subset$pos)
        max_bp<-max(ss_subset$pos)
        chr<-ss_subset$chr[1]
        
        finemap_summary$CS_span[j]<- paste0("chr",chr,":",min_bp,"-",max_bp) #span of credible set
        
        Genes_subset<- Genes[Genes$chromosome_name == chr & (
          (Genes$start_window >= min_bp & Genes$start_window <= max_bp) | #Test if start position is within range
            (Genes$end_window >= min_bp & Genes$end_window <= max_bp) |   #or if end position is within range
            (Genes$start_window <= min_bp & Genes$end_window >= max_bp)   #or if start and end positions are both outside range [gene straddles window]
        ),]
        
        if(nrow(Genes_subset) > 0){
          #Write the gene names
          finemap_summary$Genes_near_span[j]<-paste(Genes_subset$external_gene_name, collapse=', ')
          
          #Save details for genes near to credible set #NO MENTION OF THIS OUTPUT IN THE REPORT
          sets_outpath<- file.path(tabdir,paste0("nearby_genes_",trait,"_cs",j,".csv"))
          Genes_subset %>%
            dplyr::select(-c(start_window,end_window)) %>%
            write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
          
        }
      }
      finemap_summary$variable <- NULL
      
      #Return output if there has been a credible set
      
    } else {
      finemap_summary <- "No 95% confidence credible sets could be identified"
    }
    
    #Sink directly to file
    sink(file = logfile, append = T)
    cat("------------------------------\n")
    cat("SuSiE finemap result for", trait,":\n")
    print(finemap_summary)
    cat("\n",tab_out)
    cat("------------------------------\n")
    sink()
    
    #Return results just in case
    return(list(finemap_summary=finemap_summary,tab_out=tab_out,csFound=csFound, sets=sets))
  }
  
  #Catch failures in susie
  susiefail <- function(x=NULL,ntrait,isError=FALSE){warning(x)
    if(isError==TRUE){
      #Flag the fail in the global environment, only if there is a full error; warnings will not stop downward work
      assign(paste0("msg",ntrait),TRUE,envir=.GlobalEnv)
      
      type<- "error"
    } else {
      type<- "warning"
    }
    
    #If triggered, Return the error/warning in summary file
    sink(file = logfile, append = T)
    cat("------------------------------\n")
    cat("SuSiE fine-mapping ", type," produced for", traits[ntrait],". Please see the following:\n")
    cat(type," in", toString(last.warning),":\n",names(last.warning),"\n")
    cat("------------------------------\n")
    sink()
  }
  
  sink(file = logfile, append = T)
  cat("\n######\n### SuSiE fine-mapping results\n######\n\n")
  sink()
  #Run SuSiE for both datasets and generate report summaries
  #A guideline for N is specified since this is highly recommended
  msg1 <- FALSE
  tryCatch(susie1 <- runsusie(sums1.region,n=max(sums1.region$N)),
           #warning = function(x){susiefail(x,1)},
           error   = function(x){susiefail(x,1,isError=TRUE)})
  msg2 <- FALSE
  tryCatch(susie2 <- runsusie(sums2.region,n=max(sums2.region$N)),
           #warning = function(x){susiefail(x,2)},
           error   = function(x){susiefail(x,2,isError=TRUE)})
  
  
  if(msg1==FALSE){
    susie1_rep <- susie_report(susie.fit=susie1,basedata=sums1.region,trait=traits[1])
  } else {
    #Empty list for downstream logic-checks
    susie1_rep <- list(csFound=FALSE,sets=data.frame(snp=snplist,
                                                     cs=factor(NA_character_),
                                                     variable_prob=NA_real_))
  }
  
  if(msg2==FALSE){
    susie2_rep <- susie_report(susie2,sums2.region,trait=traits[2])
  } else {
    #Empty list for downstream logic-checks
    susie2_rep <- list(csFound=FALSE,sets=data.frame(snp=snplist,
                                                     cs=factor(NA_character_),
                                                     variable_prob=NA_real_))
  }
  
  #Flag either of the SuSiE calls failed
  if(any(msg1,msg2)){
    
    ######
    ### Check alignment of Beta and LD, may lead to issues with LD matrix convergence if not aligned in the same direction
    ######
    pdf(file=file.path(figdir,"Beta_LD_alignment.pdf"),width=14,height=7)
    par(mfrow=c(1,2))
    check_alignment(sums1.region)
    check_alignment(sums2.region)
    dev.off()
    
    sink(file = logfile, append = T)
    cat("The SuSiE fine-mapping step failed for at least one of the two traits (see above).\n")
    cat("The figure 'Beta_LD_alignment.pdf' has also been generated, which allows checking of alignment between summary statistic beta's and the LD matrix.\nSee https://chr1swallace.github.io/coloc/articles/a02_data.html for details.\n")
    sink()
    
  } else if(!all(susie1_rep$csFound,susie2_rep$csFound)){
    sink(file = logfile, append = T)
    cat("Credible sets were not identified for at least one trait, thus coloc.susie cannot be utilised.\n")
    sink()
  }
} else {
  #If susie is skipped entirely, produce some dummy values that are required for subsequent logic checks
  susie1_rep <- susie2_rep <- list(csFound=FALSE, sets=data.frame(snp=snplist,
                                                                  cs=factor(NA_character_),
                                                                  variable_prob=NA_real_))
  msg1 <- msg2 <- FALSE
}

######
### Prepare for, and then generate Summary plots comparing the region-results for the two GWAS
######
if(length(opt$GWASsumplots)>0){
  
  #Extract PIPs for each trait 
  snp_PIP <- rbind(
    cbind(susie1_rep$sets[,c("snp","variable_prob")],trait=traits[1]),
    cbind(susie2_rep$sets[,c("snp","variable_prob")],trait=traits[2])
  )
  
  #Combine SuSiE PIP results with the minimal dataset
  minimal_P1P2_df <- minimal_P1P2_df %>%
    full_join(snp_PIP,by=c("snp","trait"))  #add each PIP
  
  #According to whether any CS have been found, add a CS column to the dataframe
  if(susie1_rep$csFound || susie2_rep$csFound){
    
    #Extract minimal credible set labels, using custom function
    snp_CS<- joinLabels(x=susie1_rep$sets[,c("snp","cs")],y=susie2_rep$sets[,c("snp","cs")],traits=traits)
  
      
    #Combine SuSiE results with the minimal dataset
    minimal_P1P2_df <- minimal_P1P2_df %>%
      full_join(snp_CS,by="snp")          #add CS assignments
      
    
    colourMapping <- "cs" #Set colour attribute 
  } else {
    # #If no SuSiE, assign an empty column
    minimal_P1P2_df$cs <- NA_character_
    
    colourMapping <- NULL #Set colour attribute 
  }
  
  #If not including finemapping, override colourmapping and set to null
  if(opt$GWASsumplots_incfinemapping==FALSE){
    colourMapping <- NULL
  }

  
  #Dynamically plot gwas stat summary figures, varying the y-axis accordingly. This is subsequently called within lapply
  #Save files internally, or return plots, depending on the returnplot argument
  #Internally, recode plotting according to the element specified to 'yaxis'.
  ggsummaryplot <- lapply(opt$GWASsumplots,ggSummaryplot,xlim=c(reg_range["start"],reg_range["stop"]),colourMapping=colourMapping,figdir=figdir,traits=traits,
                          returnplot=opt$GWASsumplots_onefile,facetTraits=TRUE,alignment=opt$genomeAlignment)
  
  #Optionally combine all summary plots into a single file; this will be in the order specified 
  if(opt$GWASsumplots_onefile){
  
    if(length(ggsummaryplot)>1){
      #Save the arranged plot using custom function wrapped around egg::ggarrange
      jointPlots <- egg_ggarr_wlegend(ggsummaryplot,ncol=1)
      
    } else {
      #If only one plot, use it 'as is'
      jointPlots <- ggsummaryplot
      
    }
    
    height=50*length(ggsummaryplot)
    ggsummaryfile <- ggsave(file.path(figdir,paste0(paste0(traits,collapse="_"),"_summary_plots.pdf")),
                            jointPlots,device="pdf",units="mm",width=175,height=height)
    
    #Save the file locations only. Cat this to log file after colocalisation steps
    ggsummaryfile <- basename(ggsummaryfile)
    
  } else {
    #If written as separate files, save the file locations only
    ggsummaryfile <- basename(unlist(ggsummaryplot))
    
  }
}
######
### Proceed with colocalisation step
######
sink(file = logfile, append = T)
cat("\n######\n### Colocalisation results\n######\n\n")
sink()

#Character vector to flag which coloc analyses have been performed
coloc_performed <- vector(mode="character",length=0L)

#If either SuSiE call failed, a credible set has not been found for both traits, or if analysis is passed direct to coloc, run coloc.abf
if(any(msg1,msg2) || !all(susie1_rep$csFound,susie2_rep$csFound) || opt$runMode %in% c("doBoth","skipSusie")){  
  clc.abf<- coloc.abf(dataset1=sums1.region, dataset2=sums2.region)

  sink(file = logfile, append = T)
  cat("Colocalisation will now be performed without passing first to SuSiE [see coloc::coloc.abf].\n")
  cat("Thus, the single causal variant assumption has not been relaxed.\n")
  cat("coloc.abf was performed with the following priors:\n")
  print(clc.abf$priors)
  cat("coloc.abf results summary:\n")
  print(clc.abf$summary)
  cat("This summary is also returned in the file: results_summary_coloc_abf.csv\n")
  sink()
  
  #Save the results summary in a table which can be readily combined with other outputs
  Sum_abf<- t(enframe(c(traits,region=paste0("Chr", reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"]),clc.abf$priors,clc.abf$summary)))
  Sum_abf[1,1:length(traits)] <- paste0("TraitID_",1:length(traits))
  
  write.table(Sum_abf,file=file.path(tabdir,"results_summary_coloc_abf.csv"),sep = ",",row.names=FALSE,col.names = FALSE,quote = FALSE)
  
  #Save PP.H4.abf summaries, with additional details to file
  sets_outpath<- file.path(tabdir,"coloc.susie_snpwise_PP_H4_abf.csv")
  
  #Store in plotdata option for potential plotting
  plotdata.abf <- sums1.region %>%
    as.data.frame() %>%
    dplyr::select(snp,pos) %>%
    right_join(clc.abf$results,by="snp")
  
  write.table(plotdata.abf,file=sets_outpath,sep = ",",row.names=FALSE)
  
  sink(file = logfile, append = T)
  cat("\nSNPwise posterior probabilities of being a shared variant for",paste(traits,collapse = " & "),"under coloc.abf are tabulated in:\n", basename(sets_outpath),"\n")
  sink()
  
  #Flag which coloc analysis has been performed 
  coloc_performed <- c(coloc_performed, "coloc.abf")
}

#If both susie calls are successful and credible sets identified, run coloc.susie.
#Note that plots will overwrite any from Coloc.abf.
if(!any(msg1,msg2) && all(susie1_rep$csFound,susie2_rep$csFound) && opt$runMode %in% c("doBoth","trySusie")){
  clc<- coloc.susie(dataset1=susie1, dataset2=susie2) ###Run coloc based on susie outputs

  sink(file = logfile, append = T)
  cat("------------------------------\n")
  cat("coloc.susie was performed with the following priors:\n")
  print(clc$priors)
  invisible(print(clc$summary)) #Call summary invisibly first to avoid triggering bug where no output is printed
  cat("coloc.susie results summary:\n")
  print(clc$summary)
  cat("This summary is also returned in the file: results_summary_coloc_susie.csv.\n")
  sink()
  
  #Save the results summary in a table which can be readily combined with other outputs
  if(nrow(clc$summary)>1){
    Sum_clcsusie<- c(traits,region=paste0("Chr", reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"]),clc$priors) %>%
      t() %>%
      .[rep(1,nrow(clc$summary)),] %>%
      cbind(.,clc$summary)
  } else {
    Sum_clcsusie<- c(traits,region=paste0("Chr", reg_range["chr"],":",reg_range["start"],"-",reg_range["stop"]),clc$priors,clc$summary) %>%
      t()
  }
  colnames(Sum_clcsusie)[1:length(traits)] <- paste0("TraitID_",1:length(traits))
  
  write.table(Sum_clcsusie,file=file.path(tabdir,"results_summary_coloc_susie.csv"),sep = ",",row.names=FALSE,col.names = TRUE,quote = FALSE)
  
  coloc_performed <- c(coloc_performed, "coloc.susie") #Flag which coloc analysis have been performed 
}


######
### Prepare to plot the results of colocalisation analysis, and write table if coloc.susie is applied
#####

#For plotting, generate labels for SNPs with the top 5% posterior probability of being a shared variant
label_limit <- ceiling(length(snplist)*0.05)

#However, limit the top number of snps to 20 at most 
if(label_limit>10){
  label_limit <- 10
}

toPlot<- list()

if("coloc.abf" %in% coloc_performed){
  
  #Colour likely snps under the assumption that h4 is true: " https://chr1swallace.github.io/coloc/articles/a03_enumeration.html
  toPlot[[1]] <- plotdata.abf %>%
    arrange(desc(SNP.PP.H4)) %>%
    mutate(cs_coloc=cumsum(SNP.PP.H4),                                             #Establish coloc.credible set
           thresh=if_else(row_number() <= label_limit, as.character(snp),""), #Label top snps
           cs_coloc=case_when(row_number() == 1 ~ "within set",               #Top snp is always within set
                              lag(cs_coloc) < 0.95 ~ "within set",             #lag checks previous record. If this value is <0.95 then snp is in set
                              TRUE ~ "outside set"),
           cs_coloc= factor(cs_coloc,levels=c("within set","outside set")))
}

if("coloc.susie" %in% coloc_performed){
  
  #More descriptive results tabulation
  clc$results <- sums1.region %>%
    as.data.frame() %>%
    dplyr::select(snp,pos) %>%
    full_join(snp_CS,by="snp") %>%
    full_join(clc$results,by="snp") %>%
    rename(cs_susie=cs)
  
  #Save PP.H4 summaries, with additional details, to file
  sets_outpath<- file.path(tabdir,"coloc.susie_snpwise_PP_H4_abf.csv")
  write.table(clc$results,file=sets_outpath,sep = ",",row.names=FALSE)
  
  sink(file = logfile, append = T)
  cat("\nSNPwise posterior probabilities of a shared variant for",paste(traits,collapse = " & "),"under coloc.susie are tabulated in:\n", basename(sets_outpath),"\n")
  sink()
  
  #Prepare plotting for each 'row' of coloc.susie
  for(i in 1:nrow(clc$summary)){
    
    #Extract a given plotdata column
    plotdata <- clc$results[,c(1:3,i+3)]
    #clc_col_index <- which(grepl("SNP.PP.H4",colnames(plotdata)))
    
    #Assign labels to top X% of SNPs, arranged by PP in column
    plotdata<- plotdata %>%
      arrange(desc(.[[4]])) %>%
      mutate(cs_coloc=cumsum(.[[4]]),                                                #Establish coloc.credible set
             thresh=if_else(row_number() <= label_limit, as.character(snp),""), #Label top snps
             cs_coloc=case_when(row_number() == 1 ~ "within set",               #Top snp is always within set
                                lag(cs_coloc) < 0.95 ~ "within set",             #lag checks previous record. If this value is <0.95 then snp is in set
                                TRUE ~ "outside set"),
             cs_coloc= factor(cs_coloc,levels=c("within set","outside set")))
      
  toPlot[[length(toPlot)+1]] <- plotdata
  }
  
}
sink(file = logfile, append = T)
cat("------------------------------\n")
sink()

######
### Produce plots recurrently across toPlot list
#####
for(i in 1:length(toPlot)){
  
  #Extract plotting dataframe
  clc_col_index <- grep("SNP.PP.H4",colnames(toPlot[[i]]),value = TRUE)
  plotdata<- toPlot[[i]] %>%
    rename(SNP.PP=all_of(clc_col_index))
  
  #Set parameters for loop according to whether a coloc.abf or coloc.susie analysis is being plotted
  if(("coloc.susie" %in% coloc_performed && !"coloc.abf" %in% coloc_performed) ||
     ("coloc.susie" %in% coloc_performed && "coloc.abf" %in% coloc_performed && i!=1)){
    
    #Identify the current analysis, for later logic checks
    current <- "susie"
    
    # #Set colour mapping and legend
    colourMapping = "cs_susie"
    nameColourLegend<- "SuSiE fine-mapping\n(Trait: 95% credible set)"
    
    #Determine filename for loop, first identify which cs are compared, then name accordingly
    if("coloc.abf" %in% coloc_performed){ 
      ind <- i-1
    } else {
      ind <- i
    }
    cs_index<- clc$summary[ind,c("idx1","idx2")]
    cs_label <- paste(traits,cs_index,sep=":")
    cs_filenm <- paste(paste(traits,cs_index,sep="cs"),collapse="_")
    
    filename<- file.path(figdir,paste0("coloc.susie_result_all_snps_",cs_filenm,".pdf"))
    
  } else {
    #Identify the current analysis, for later logic checks
    current <- "abf"
    
    # # #Set colour mapping and legend
    colourMapping <- NULL
    nameColourLegend <- NULL
    
    #Determine filename for loop
    cs_filenm <- ".abf"
    filename<- file.path(figdir,"coloc.abf_result_all_snps.pdf")
    
  }
  
  #Set shape mapping and legend
  shapeMapping <- "cs_coloc"
  nameShapeLegend <- "Colocalisation\n(95% credible set\nassuming shared\nvariant)"
  
  #Build all snps plot, add labels for snps
  snp_PP <- ggSummaryplot(yaxis="SNP.PP",
                          xstring="pos",
                          xlim=c(reg_range['start'],reg_range['stop']),
                          dset=plotdata,
                          colourMapping=colourMapping,
                          shapeMapping=shapeMapping,
                          figdir=figdir,
                          traits=traits,
                          returnplot=TRUE,
                          facetTraits = FALSE,
                          nameColourLegend=nameColourLegend,
                          nameShapeLegend=nameShapeLegend,
                          alignment=opt$genomeAlignment) +
    geom_text_repel(aes(label=thresh), max.overlaps = 20, na.rm=TRUE, show.legend = FALSE)
  
  #Saveplot
  ggsave(filename,snp_PP,device="pdf",units="mm",width=150,height=175)
  
  
  #### Replot colocalised snps based on nearby genes
  min_bp<-min(plotdata$pos[plotdata$cs_coloc=="within set"])-gene_window #10KB
  max_bp<-max(plotdata$pos[plotdata$cs_coloc=="within set"])+gene_window #10KB
  chr<- reg_range["chr"]
  
  #Extract genes within the start or stop positions within 
  #Genes_subset<-Genes[Genes$start_position > min_bp & Genes$end_position < max_bp & Genes$chromosome_name == chr,] %>%
  Genes_subset <- Genes[Genes$chromosome_name == chr & (
    (Genes$start_window > min_bp & Genes$start_window < max_bp) |
      (Genes$end_window > min_bp & Genes$end_window < max_bp) |
      (Genes$start_window < min_bp & Genes$end_window > max_bp)
  ),]
  
  #If nearby snps are found, do further plotting, otherwise write message
  if(nrow(Genes_subset)>0){
    
    Genes_subset <- Genes_subset %>%
      arrange(start_position) %>%                      #Sort by start position
      mutate(midpoint=(start_position+end_position)/2, #Determine middle of gene position
             external_gene_name=factor(external_gene_name,levels = rev(external_gene_name[!duplicated(external_gene_name)]))) #Save as factor variable, to maintain sort order
    

    #Save details for nearby genes
    sets_outpath<- file.path(tabdir,paste0("nearby_genes_coloc",cs_filenm,".csv"))
    Genes_subset %>%
      dplyr::select(-c(start_window,end_window,midpoint)) %>%
      write.table(.,file=sets_outpath,sep = ",",row.names=FALSE)
    
    sink(file = logfile, append = T)
    
    if(current=="susie"){
      cat("\nGenes located within a 10Kb window around the top 10% of snps from credible sets are tabulated in: ", basename(sets_outpath),"\n")
    } else {
      cat("\nGenes located within a 10Kb window around the top 10% of coloc.abf snps are tabulated in: ", basename(sets_outpath),"\n")
    }
    sink()
    
    if(!is.null(opt$restrict_nearby_gene_plotting_source)){ #If subsetting to named gene sources
      
      geneSources <-strsplit(opt$restrict_nearby_gene_plotting_source,split=",")[[1]] #String split on comma to identify sources
      sourceSubset<- which(Genes_subset$external_gene_source %in% geneSources)        #Find matching rows
      
      if(length(sourceSubset)>0){                                                     #If at least one gene remains, subset
        Genes_subset<- Genes_subset[sourceSubset,]
      } else {
        sink(file = logfile, append = T)
        cat("\nCould not subset nearby gene plotting by source since no genes remained after restricting to", paste0(geneSources,collapse=", "), "\n")
        sink()
      }
    }
    
    #Identify the x axis range based on max and minimum gene windows - plot only genes with a HGNC symbol
    #plot_rng <- c(min(Genes_subset$start_window[Genes_subset$external_gene_source=="HGNC Symbol"]),max(Genes_subset$end_window[Genes_subset$external_gene_source=="HGNC Symbol"]))
    plot_rng <- c(min(c(min_bp,Genes_subset$start_window)),max(c(max_bp,Genes_subset$end_window)))
    
    
    #Rescale x-axis into MBs or KBs
    if((plot_rng[2]-plot_rng[1])>1000000){
      xscale <- 1000000
      xscale_magnitude <- " [Mb]"
    } else if ((plot_rng[2]-plot_rng[1])>1000) {
      xscale <- 1000
      xscale_magnitude <- " [Kb]"
    } else {
      xscale <- 1
      xscale_magnitude <- ""
    }

    if(is.null(opt$gene_tracks) || (nrow(Genes_subset)<opt$gene_tracks && !is.null(opt$gene_tracks))){
      #Plot nearby genes using a unique plotting approach, scaling axes accordingly
      gene_near <- Genes_subset %>%
        ggplot(.,aes(x=midpoint, y=external_gene_name))+
        geom_errorbar(aes(xmin=start_position,xmax=end_position),width=0.2)+
        theme_bw()+
        theme(axis.text.y = element_text(face="italic"))
      
    } else {
    ## USE A REVISED PLOTTING APPROACH - permits multiple genes on one y-axis level, buffered by genomic position
    
    genespacing<- (plot_rng[2]-plot_rng[1])/5
      
    Genes_subset$track <- 1           #Assign all genes to track 1 initially
    for(t in 2:nrow(Genes_subset)){   #For each gene, tracks upwards to avoid overlap with those in current track
      prior <- Genes_subset[1:(t-1),]
      
      r=1                             #Start from track number 1, and while overlapping, increase tracks until adequate plotting space is found
      inTrack<- which(prior$track==r) #identify rows in current track
      while(length(inTrack)>0){ #While in an existing track
        if(Genes_subset$start_position[t]>(max(prior$end_position[inTrack])+genespacing)){ #If the start position is more than 100Kb apart from the previous gene in track, then assign gene to track
          Genes_subset$track[t] <- r
          break #break loop
          
        } else { #increase track number
          r <- r+1
          inTrack<- which(prior$track==r) #identify rows in current track
          if(length(inTrack)==0){ #If this is a new track, assign final track number and loop will break
            Genes_subset$track[t] <- r
          }
        }
      }
    } #End tracking loop
    
    #Convert to factor in order to display lower tracks higher
    tracklevels<- rev(sort(unique(Genes_subset$track)))
    Genes_subset$track <- factor(Genes_subset$track,levels=tracklevels) 
    
    #Plot nearby genes using a unique plotting approach, scaling axes accordingly
    gene_near <- Genes_subset %>%
      ggplot(.,aes(x=midpoint, y=track))+
      geom_text_repel(aes(label=external_gene_name),fontface="italic",direction="y",size=3)+
      theme_bw()+
      theme(axis.text.y = element_blank(),
            axis.ticks.y = element_blank())
    }
    
    #Add universal plot layers
    gene_near <- gene_near + 
      geom_errorbar(aes(xmin=start_position,xmax=end_position),width=0.1)+
      scale_x_continuous(limits = plot_rng, labels=scales::label_number(scale = 1 / xscale,accuracy = 0.01))+ #Scale axis magnitude dynamically
      labs(x=paste0("GRCh",opt$genomeAlignment," genomic position (Chr", reg_range["chr"],":",plot_rng[1],"-",plot_rng[2],")",xscale_magnitude),
           y="Nearby genes")

    
    #Narrow the snp plot xlim to match gene_near
    suppressMessages({ #Suppress warning about 'double-setting' xlim
      snp_PP_range <- snp_PP +
        scale_x_continuous(limits = plot_rng, labels=scales::label_number(scale = 1 / xscale,accuracy = 0.01)) #Scale axis magnitude dynamically
    })
    
    #If susie has been plotted, colouring is used to label Susie credible sets, adjust legend to include only snps in the new plot range
    if(current=="susie"){ 
      #To ensure consistent colouring when reassigning the colour factor, assign factor levels to specific colours
      levels<- levels(plotdata[[colourMapping]])
      col_levels <-ggpalette[1:length(levels)]
      names(col_levels)<- levels
      
      suppressMessages({ #Suppress warning about redoing existing legend
        snp_PP_range <- snp_PP_range +
          scale_colour_manual(na.value = "black", values=col_levels,
                              breaks = levels(droplevels(plotdata[which(plotdata$pos > plot_rng[1] & plotdata$pos < plot_rng[2]),colourMapping])))
      })
    }
    
    #Scale plot proportions according to number of genes plotted, but cap at 1, indicating equal proportions
    
    #To accommodate labelling when using track-based plotting, give extra buffer room per track
    if(is.null(opt$gene_tracks) || (nrow(Genes_subset)<opt$gene_tracks && !is.null(opt$gene_tracks)) ){
      propor <- 0.05*length(gene_near$data$external_gene_name)
    } else {
      propor <- 0.2*length(levels(gene_near$data$track))
    }
    if(propor>1){propor <- 1}
    
    g_arr <- egg_ggarr_wlegend(list(snp_PP_range,gene_near),position = "right",ncol=1,heights=c(1,propor))
    
    #If plotting the result of coloc.susie analysis, add extra info relevant to credible set assignments 
    if(current=="susie"){
      filename<- file.path(figdir,paste0("coloc_susie_likely_snps_with_genes",cs_filenm,".pdf"))
      
    } else {
      filename<- file.path(figdir,"coloc_abf_likely_snps_with_genes.pdf")
    }
    
    ggsave(filename,g_arr,device="pdf",units="mm",width=150,height=175)
    
  } else { #Conditional statement for when no nearby genes are found
    
    sink(file = logfile, append = T)
    
    if(("coloc.susie" %in% coloc_performed && !"coloc.abf" %in% coloc_performed) ||
       ("coloc.susie" %in% coloc_performed && "coloc.abf" %in% coloc_performed && i!=1)
    ){
      cat("\nNo genes were identified within a 10Kb window around snps from the current credible sets comparison:",gsub("_"," & ",cs_filenm),".\n")
    } else {
      cat("\nNo genes were identified within a 10Kb window around the top 10% of coloc.abf snps.\n")
    }
    sink()
    
  }
  
} 

sink(file = logfile, append = T)
cat("------------------------------\n")
sink()



#Write to log which GWAS summary plots have been written
sink(file = logfile, append = T)
cat("Selected graphical comparison between summary statistics has been written to the file(s):\n",
    paste0(ggsummaryfile,sep="\n"),"\n")
sink()
